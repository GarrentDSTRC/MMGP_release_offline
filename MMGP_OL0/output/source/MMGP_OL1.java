/* autogenerated by Processing revision 1286 on 2023-07-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import org.apache.commons.codec.binary.*;
import org.apache.commons.codec.*;
import org.apache.commons.codec.digest.*;
import org.apache.commons.codec.language.bm.*;
import org.apache.commons.codec.language.*;
import org.apache.commons.codec.net.*;
import org.apache.commons.codec.cli.*;
import org.apache.commons.logging.*;
import org.apache.commons.logging.impl.*;
import org.apache.ws.commons.serialize.*;
import org.apache.ws.commons.util.*;
import org.apache.xmlrpc.applet.*;
import org.apache.xmlrpc.secure.sunssl.*;
import org.apache.xmlrpc.util.*;
import org.xml.sax.*;
import uk.co.wilson.xml.*;
import uk.org.xml.sax.*;
import org.apache.xmlrpc.*;
import org.apache.xmlrpc.secure.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class MMGP_OL1 extends PApplet {

 //<>//
RotatingFoil test; //<>//
SaveData dat;

float maxT;
String datapath;//输出数据保存的路径

int Re = 500, nflaps = 20;//拍动次数
float hc = 1, chord = 1.0f;
//changed parameters
// theta0 5:5:40, AD = 0.1:0.1:0.6, Phi = 0:30:180, St = 0.1:0.04:03
float theta0 = 5, AD = 0.1f, Phi=0, St = 0.05f;//初始化运动参数
int Num = 1;
String Sp;
float CT = 0, CL = 0, CP = 0,Eta=0;
float y = 0, angle = 0;
int resolution = 32, xLengths=16, yLengths=16, zoom = 2;//zoom:画幅放大倍数
int picNum = 10;//图片数量
float tCurr = 0, tStep = .005f;
int count=0;//OL新加入的变量
int testcount=1;
float nacaName1 = 0,nacaName2 = 0,nacaName3 = 15;//初始翼型

 public void settings(){
  size(zoom*xLengths*resolution, zoom*yLengths*resolution);//设置画幅尺寸
}
 public void setup() {
  datapath = "Re500"+"/" + str(nacaName1)+str(nacaName2) +str(nacaName3)+ '_' + "St="+str(St)+"_AD="+str(AD)+"_theta="+str(theta0)+"_Phi="+str(Phi);//文件保存路径

  setUpNewSim();
}
 public void draw() {
  
  test.update2();
  
  double angle=(test.foil.phi-PI)*180/PI;//单位为度数
  PVector forces = test.foil.pressForce(test.flow.p);
  PVector coordinate = test.foil.xc;
  y = coordinate.y - yLengths * resolution / 2.f;
  PVector deltaxy = test.foil.dxc;
  float phivel = test.foil.dphi*resolution/test.dt; // with unit of rad/s
  float vely = deltaxy.y*resolution/test.dt;
  float M = test.foil.pressMomentpiv(test.flow.p, 1.f/4*resolution, 0);
    
  if(test.t>=maxT/20*2){
    count+=1;
    CT += -forces.x / resolution * 2;
    CP += ((M*phivel/resolution)+(forces.y*vely));
    CL += forces.y / resolution * 2;
    Eta=CT*2*resolution/CP;
  }
  //Sp = SparsePressure(test);
  //dat.addData(test.t, test.foil.pressForce(test.flow.p), test.foil, test.flow.p);
  //dat.addDataSimple(test.t, test.foil.pressForce(test.flow.p));
  dat.output.println(test.t+" " + test.foil.pressForce(test.flow.p).x+ " "+test.foil.pressForce(test.flow.p).y +" "+test.foil.phi+" "+phivel+" "+ y +" "+vely+" "+ Eta +" "+ CP +" "+ M +" "+ test.foil.dphi +" "+ angle +";");//" "+ Sp +";");
  
  if(test.t<maxT/20*4){
    test.display();
    picNum--;
    if(picNum <= 0){
      saveFrame(datapath + "/" +"frame-#######.png");
      picNum = 30;
    }
  }
  
  
  if (test.t>=maxT/20*8 || testcount==1) {
    dat.finish();
   if (test.t>=maxT/20*8 ){
      // 写入结果, 更改flag;
    PrintWriter output_average1=createWriter("dataY.txt");
    //output_average1.println(CT/count+","+CT/count*2*resolution/(CP/count));
    output_average1.println(CT/count+","+CL/count);
    output_average1.close();
    PrintWriter flg=createWriter("flag.txt");
    flg.println("1");//跑完过后把flag改成1
    flg.close();
    
    //print("test count"+testcount);
   }
   else{
   testcount+=1;
   }
    //更改参数
    BufferedReader input_flag = createReader("flag.txt");
    String content;
    try {
      content = input_flag.readLine();
    } catch (IOException e) {
      e.printStackTrace();
      content = null;
    }
    String[] pieces = split(content, TAB);
    int flagGP = PApplet.parseInt(pieces[0]);
    println("This is the flagGP : "+ flagGP);
  
  
  
  while(flagGP==1){
      //
      input_flag = createReader("flag.txt");
      try {
        content = input_flag.readLine();
      } catch (IOException e) {
        e.printStackTrace();
        content = null;
      }
      pieces = split(content, TAB);
      flagGP = PApplet.parseInt(pieces[0]);
      println("This is flagGP : "+ flagGP);
      //
      delay(500);
    };///
  
     BufferedReader input_newParam = createReader("dataX.txt");
    String content1;
    try {
      content1 = input_newParam.readLine();
    } catch (IOException e) {
      e.printStackTrace();
      content1 = null;
    }
    String[] pieces1 = split(content1, ",");
    St = PApplet.parseFloat(pieces1[0]);AD = PApplet.parseFloat(pieces1[1]);
    theta0 = PApplet.parseFloat(pieces1[2]);Phi = PApplet.parseFloat(pieces1[3]);nacaName1 = PApplet.parseFloat(pieces1[4]);nacaName2 = PApplet.parseFloat(pieces1[5]);nacaName3 = PApplet.parseFloat(pieces1[6]);
    
    datapath = "Re500"+"/" +  str(nacaName1)+str(nacaName2) +str(nacaName3) + '_' + "St="+str(St)+"_AD="+str(AD)+"_theta="+str(theta0)+"_Phi="+str(Phi);
       CT = 0; CL = 0; CP = 0;Eta=0;count=0; 
    setUpNewSim();  
  }
}


 public void setUpNewSim(){
  //创建新的simulation
  //float AoA = 5.0*runNum;
  
  //new File(datapath + "Theta" +str(theta0) + "AD" + str(AD) + "_" + str(Stnum) + "_" + str(Phinum)).mkdir();
  float dAoA = theta0*PI/180.f, uAoA = dAoA;
  float dA = AD*resolution, uA = dA;
  float phi = Phi*PI/180.f;
  float st = St;
  if(St < 0.8f){
    maxT = chord/0.3f*nflaps;
  }
  else{
  maxT = chord/St*nflaps;
  }
  test = new RotatingFoil(resolution, xLengths, yLengths, tStep, nacaName1,nacaName2,nacaName3, Re, true);
  test.setFlapParams(st,dAoA,uAoA,dA,uA,phi);
  dat = new SaveData(datapath + "/force.txt", test.foil.coords, resolution, xLengths, yLengths, zoom);
    dat.output.println("t"+" "+"fx"+" "+"fy"+" "+"theta"+" "+"thetavel"+" "+"y"+" "+"yvel"+" "+"Eta"+" "+"CP"+" "+"M"+" "+"Dphi"+" "+"Angle");
}
/*********************************************************
solve the BDIM equation for velocity and pressure

  u = del*F+[1-del]*u_b+del_1*ddn(F-u_b)
  
  where 
    del is the zeroth moment of the smoothing kernel integral
    del_1 is the first moment (zero if mu1=false)
    u_b is the body velocity
    F is the fluid equation of motion:
    if(QUICK):
      F(u) = u(t)+\int_t^{t+dt} grad(u*u)+\mu*laplace(u)+g-grad(p)/rho \d t
    else(SEMI-LAGRANGIAN)
      F(u) = u(t,x(t))+\int_t^{t+dt} g-grad(p)/rho \d t
      
    where x(t) is the back-casted location of the grid points
      x(t) = x-\int_t^{t+dt} u \d t

Example code:

BDIM flow;
void setup(){
  size(400,400); 
  int n=(int)pow(2,7);
  flow = new BDIM(n,n,0.,new CircleBody(n/3,n/2,n/8,new Window(n,n)),n/8000.,true);
}
void draw(){
  flow.update();        // project
  flow.update2();       // correct
  flow.p.display(-1,1); // display pressure
}
*********************************************************/
class BDIM{
  int n,m; // number of cells in uniform grid
  float t=0, dt, nu, eps=2.0f;
  PVector g= new PVector(0,0);
  VectorField u,del,del1,c,u0,ub,wnx,wny,distance,rhoi;
  Field p;
  boolean QUICK, mu1=true, adaptive=false;

  BDIM( int n_, int m_, float dt_, Body body, VectorField uinit, float nu_, boolean QUICK_ ){
    n = n_+2; m = m_+2;
    dt = dt_;
    nu=nu_;
    QUICK=QUICK_;
    if(!QUICK && nu!=0) {
      println("Semi-lagrangian advection cannot include explicit value for `nu`.");
      exit();
    }

    u = uinit;
    if(u.x.bval!=0) u.x.gradientExit = true;
    u0 = new VectorField(n,m,0,0);
    p = new Field(n,m);
    if(dt==0) setDt(); // adaptive time stepping for O(2) QUICK

    ub  = new VectorField(n,m,0,0);
    distance =  new VectorField(n, m, 10, 10);    
    del = new VectorField(n,m,1,1);
    del1 = new VectorField(n,m,0,0);
    rhoi = new VectorField(del);
    c = new VectorField(del);
    wnx = new VectorField(n,m,0,0);
    wny = new VectorField(n,m,0,0);
    get_coeffs(body);
  }
  
  BDIM( int n, int m, float dt, Body body, float nu, boolean QUICK, float u_inf){
    this(n,m,dt,body,new VectorField(n+2,m+2,u_inf,0),nu,QUICK);}
  BDIM( int n, int m, float dt, Body body, float nu, boolean QUICK ){
    this(n,m,dt,body,new VectorField(n+2,m+2,1,0),nu,QUICK);}
  
  // If no body is supplied, create a body outside the domain
  BDIM( int n, int m, float dt, VectorField uinit, float nu, boolean QUICK ){
    this(n,m,dt,new CircleBody(-n/2,-m/2,n/10,new Window(0,0,n,m)),uinit,nu,QUICK);}
  
  BDIM( int n, int m, float dt, Body body){this(n,m,dt,body,new VectorField(n+2,m+2,1,0),0,false);}
  
   public void update(){
    // O(dt,dx^2) BDIM projection step:
    c.eq(del.times(rhoi.times(dt))); 
    u0.eq(u);
    VectorField F = new VectorField(u);
    if(QUICK) F.AdvDif( u0, dt, nu );
    else F.advect( dt, u0 );
    updateUP( F, c );
  }
  
   public void update2(){
    // O(dt^2,dt^2) BDIM correction step:
    VectorField us = new VectorField(u), F = new VectorField(u);
    if(QUICK){
      F.AdvDif( u0, dt, nu );
      updateUP( F, c );
      u.plusEq(us); 
      u.timesEq(0.5f);
      if(adaptive) dt = checkCFL();
    }
    else{
      F.eq(u0); 
      F.advect(dt,us,u0);
      VectorField dp = p.gradient().times(rhoi.times(0.5f*dt));
      dp.advect(dt,us,u0);
      updateUP( F.minus(dp), c.times(0.5f), F.minus(ub) );
    }
    t += dt;
  }
  
   public void updateUP( VectorField R, VectorField coeff, VectorField du ){
/*  Seperate out the pressure from the forcing
      del*F = del*R+coeff*gradient(p)
    Approximate update (dropping ddn(grad(p))) which doesn't affect the accuracy of the velocity
      u = del*R+coeff*gradient(p)+[1-del]*u_b+del_1*ddn(R-u_b)
    Take the divergence
      div(u) = div(coeff*gradient(p)+stuff) = 0
    u.project solves this equation for p and then projects onto u
*/
    R.plusEq(PVector.mult(g,dt));
    u.eq(del.times(R).minus(ub.times(del.plus(-1))));
    if(mu1) u.plusEq(del1.times(du.normalGrad(wnx,wny)));
    u.setBC();
    p = u.project(coeff,p);    
  }
   public void updateUP( VectorField R, VectorField coeff){updateUP( R, coeff, R.minus(ub));}

   public void update( Body body ){
    if(body.unsteady()){get_coeffs(body);}else{ub.eq(0.f);}
    update();
  }
   public void update2( Body body ){update2();} // don't need to get coeffs again

   public void get_coeffs( Body body ){
    get_dist(body);
    get_del();
    get_del1();
    get_ub(body);
    get_wn(body);
  }
  
   public void get_ub( Body body ){
    /* Immersed Velocity Field
          ub(x) = U(x)*(1-del(x))
    where U is the velocity of the body */
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
        ub.x.a[i][j] = body.velocity(1,dt,(float)(i-0.5f),j);
        ub.y.a[i][j] = body.velocity(2,dt,i,(float)(j-0.5f));
    }}
  }
  
   public void get_wn(Body body){
   /* wall normal direction of the closest body point */
   PVector wn;
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      wn = body.WallNormal((float)(i-0.5f),j);
      wnx.x.a[i][j]=wn.x;
      wny.x.a[i][j]=wn.y;
      wn = body.WallNormal(i,(float)(j-0.5f));
      wnx.y.a[i][j]=wn.x;
      wny.y.a[i][j]=wn.y;
    }}   
  }
  
   public void get_dist( Body body ) {
    for ( int i=1 ; i<n-1 ; i++ ) {
      for ( int j=1 ; j<m-1 ; j++ ) {
        distance.x.a[i][j] = body.distance((float)(i-0.5f), j);
        distance.y.a[i][j] = body.distance(i, (float)(j-0.5f));
      }
    }
  }
  
   public void get_del( ){
    /* BDIM zeroth order moment
          del(x) = delta0(d(x))
    where d is the distance to the interface from x */
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
        del.x.a[i][j] = delta0(distance.x.a[i][j]);
        del.y.a[i][j] = delta0(distance.y.a[i][j]);
    }}
    del.setBC();
  }
  
   public void get_del1(){
    /* BDIM first order moment
          del(x) = delta1(d(x))
    where d is the distance to the interface from x */
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
        del1.x.a[i][j] = delta1(distance.x.a[i][j]);
        del1.y.a[i][j] = delta1(distance.y.a[i][j]);
    }}
    del1.setBC();
  }

  
   public float delta0( float d ){
    if( d <= -eps ){
      return 0;
    } else if( d >= eps ){
      return 1;
    } else{
      return 0.5f*(1.f+d/eps+sin(PI*d/eps)/PI);
    } 
  }
  
   public float delta1( float d ){
    if( abs(d) >= eps){
      return 0;
    } else{
        return 0.25f*(eps-sq(d)/eps)-1/TWO_PI*(d*sin(d*PI/eps)+eps/PI*(1+cos(d*PI/eps)));
    } 
  }
  
   public float checkCFL() { 
    return min(u.CFL(nu), 1);
  }

   public void setDt(){
    dt = checkCFL();
    if(QUICK) adaptive = true;
  }

   public void write( String name ){
    PrintWriter output;
    output = createWriter(name);
    output.println(t);
    output.println(dt);
    for ( int i=0; i<n; i++ ){
    for ( int j=0; j<m; j++ ){
      output.println(""+u.x.a[i][j]+", "+u.y.a[i][j]+", "+p.a[i][j]);
    }}
    output.flush(); 
    output.close();
  }

   public void resume( String name ){
    float[] data;
    String[] stuff = loadStrings(name);
    t = PApplet.parseFloat(stuff[0]);
    dt = PApplet.parseFloat(stuff[1]);
    for ( int i=0; i<n; i++ ){
    for ( int j=0; j<m; j++ ){
      data = PApplet.parseFloat(split(stuff[2+i*m+j],','));
      u.x.a[i][j] = data[0];
      u.y.a[i][j] = data[1];
      p.a[i][j] = data[2];
    }}
  }
}
/********************************
 Body class
 
 this is the parent of all the body classes
 
 it defines the position and motion of a convex body. 
 
 points added to the body shape must be added counter
 clockwise so that the convexity can be tested.
 
 the easiest way to include dynamics is to use follow()
 which follows the path variable (or mouse) or to use
 react() which integrates the rigid body equations.
 You can also translate() and rotate() directly.
 
Example code:
 
Body body;
void setup(){
  size(400,400);
  body = new Body(0,0,new Window(0,0,4,4));
  body.add(0.5,2.5);
  body.add(2.75,0.25);
  body.add(0,0);
  body.end();
  body.display();
  println("The distance "+body.distance(3.,1.)+" should equal "+sqrt(.5));
}
void draw(){
  background(0);
  body.follow();
  body.display();
}
void mousePressed(){body.mousePressed();}
void mouseReleased(){body.mouseReleased();}
void mouseWheel(MouseEvent event){body.mouseWheel(event);}

********************************/

class Body {
  Window window;
  int bodyColor = 0xFF993333;
  final int bodyOutline = 0xFF000000;
  final int vectorColor = 0xFF000000;
  PFont font = loadFont("Dialog.bold-14.vlw");
  float phi=0, dphi=0, dotphi=0, ddotphi=0;
  float mass=1, I0=1, area=0;
  ArrayList<PVector> coords=new ArrayList<PVector>();
  int n;
  boolean convex=false;
  boolean pressed=false, xfree=true, yfree=true, pfree=true;
  PVector xc, dxc=new PVector(), dotxc=new PVector(), ddotxc=new PVector();
  PVector handle=new PVector(), ma=new PVector();
  OrthoNormal orth[];
  Body box;

  Body( float x, float y, Window window ) {
    this.window = window;
    xc = new PVector(x, y);
  }

   public void add( float x, float y ) {
    coords.add( new PVector( x, y ) );
  }

   public void end(Boolean closed) {
    n = coords.size();
    orth = new OrthoNormal[closed?n:n-1];
    getOrth(); // get orthogonal projection of line segments
    if(closed) getArea();

    // make the bounding box
    if (n>4) {
      PVector mn = xc.copy(), mx = xc.copy();
      for ( PVector x: coords ) {
        mn.x = min(mn.x, x.x);
        mn.y = min(mn.y, x.y);
        mx.x = max(mx.x, x.x);
        mx.y = max(mx.y, x.y);
      }
      box = new Body(xc.x, xc.y, window);
      box.add(mn.x, mn.y);
      box.add(mn.x, mx.y);
      box.add(mx.x, mx.y);
      box.add(mx.x, mn.y);
      box.end();
    }
    
    // check for convexity
    convex = true;
    double_loop: for ( OrthoNormal oi : orth ) {
      for ( OrthoNormal oj : orth ){
        if(oi.distance(oj.cen.x,oj.cen.y)>0.001f) {
          convex = false; 
          break double_loop;
    }}}
  }
   public void end() {
    end(true);
  }

   public void getOrth() {    // get orthogonal projection to speed-up distance()
    for ( int i = 0; i<orth.length ; i++ ) {
      PVector x1 = coords.get(i);
      PVector x2 = coords.get((i+1)%n);
      orth[i] = new OrthoNormal(x1, x2);
    }
  }
   public void getArea() {    // get the polygon area and moment
    float s=0, t=0;
    for ( int i = 0; i<n ; i++ ) {
      PVector p1 = coords.get(i);
      PVector p2 = coords.get((i+1)%n);
      float x1 = p1.x-xc.x, x2 = p2.x-xc.x, y1 = p1.y-xc.y, y2 = p2.y-xc.y, da = x1*y2-x2*y1;
      s -= da;
      t -= (sq(x1)+x1*x2+sq(x2)+sq(y1)+y1*y2+sq(y2))*da;
    }
    area = 0.5f*s;
    I0 = t/12.f;
    mass = area; // default unit density
  }
 
   public void setColor(int c) {
    bodyColor = c;
  }
   public void display() {
    display(bodyColor, window);
  }
   public void display(Window window) {
    display(bodyColor, window);
  }
   public void display( int C) { 
    display(C, window);
  }
   public void display( int C, Window window ) { // note: can display while adding
    //    if(n>4) box.display(#FFCC00);
    fill(C);
    //noStroke();
    stroke(bodyOutline);
    strokeWeight(1);
    beginShape();
    for ( PVector x: coords ) vertex(window.px(x.x), window.py(x.y));
    endShape(CLOSE);
}
   public void displayVector(PVector V) {
    displayVector(vectorColor, window, V, "Force", true);
  }
   public void displayVector(int C, Window window, PVector V, String title, boolean legendOn) { // note: can display while adding
    //    if(n>4) box.display(#FFCC00);
    float Vscale=10;
    float circradius=6; //pix
    
    stroke(C);
    strokeWeight(2);
    line(window.px(xc.x), window.py(xc.y), window.px(xc.x-Vscale*V.x), window.py(xc.y-Vscale*V.y));
    
    fill(C); 
    noStroke();
    ellipse(window.px(xc.x-Vscale*V.x), window.py(xc.y-Vscale*V.y), circradius, circradius);
    
    if (legendOn){
        textFont(font);
        fill(C);
        float spacing=20;
        int x0 = window.x0, y1 = window.y0+window.dy;
        textAlign(LEFT,BASELINE);
        String ax = ""+V.x;
        String ay = ""+V.y;
        text(title + " X: " + ax.substring(0,min(ax.length(),5)),x0+spacing,y1-2*spacing);
        text(title + " Y: " + ay.substring(0,min(ay.length(),5)),x0+spacing,y1-spacing);
    }
  }

   public float distance( float x, float y ) { // in cells
    float dis;
    if (n>4) { // distance to bounding box
      dis = box.distance(x, y);
      if (dis>3) return dis;
    }
    
    if(convex){ // distance to convex body
      // check distance to each line, choose max
      dis = -1e10f;
      for ( OrthoNormal o : orth ) dis = max(dis, o.distance(x, y));
      return dis;
    } else {   // distance to non-convex body
      // check distance to each line segment, choose min
      dis = 1e10f;
      for( OrthoNormal o: orth ) dis = min(dis,o.distance(x,y,false));
      return (wn(x,y)==0)?dis:-dis; // use winding to set inside/outside
    }
  }
   public int distance( int px, int py) {     // in pixels
    float x = window.ix(px);
    float y = window.iy(py);
    return window.pdx(distance( x, y ));
  }

   public int wn( float x, float y){
    // Winding number. If wn==0 the point is inside the body
    int wn=0;
    for ( int i = 0; i<coords.size()-1; i++ ){      
      float yi = coords.get(i).y;    // y value of point i
      float yi1 = coords.get(i+1).y; // y value of point i+1
      OrthoNormal o = orth[i];       // segment from i to i+1
      if(yi <= y){                   // check for positive crossing
        if(yi1 > y && o.distance(x,y)>0) wn++;
      }else{                         // check for negative crossing
        if(yi1 <= y && o.distance(x,y)<0) wn--;
      }
    }
    return wn;
  }

   public PVector WallNormal(float x, float y  ) {
    PVector wnormal = new PVector(0, 0);
    float dis = -1e10f;
    float dis2 = -1e10f;
    if (n>4) { // check distance to bounding box
      if ( box.distance(x, y)>3) return wnormal;
    }
    // check distance to each line, choose max
    for ( OrthoNormal o : orth ) {
      dis2=o.distance(x, y);
      if (dis2>dis) {
        dis=dis2;
        wnormal.x=o.nx;
        wnormal.y=o.ny;
      }
    }
    return wnormal;
  }

   public float velocity( int d, float dt, float x, float y ) {
    // add the rotational velocity to the translational
    PVector r = new PVector(x, y);
    r.sub(xc);
    if (d==1) return (dxc.x-r.y*dphi)/dt;
    else     return (dxc.y+r.x*dphi)/dt;
  }

   public boolean unsteady(){return (dxc.mag()!=0)|(dphi!=0);}

   public void translate( float dx, float dy ) {
    dxc = new PVector(dx, dy);
    xc.add(dxc);
    for ( PVector x: coords ) x.add(dxc);
    for ( OrthoNormal o: orth   ) o.translate(dx, dy);
    if (n>4) box.translate(dx, dy);
  }

   public void rotate( float dphi ) {
    this.dphi = dphi;
    phi = phi+dphi;
    float sa = sin(dphi), ca = cos(dphi);
    for ( PVector x: coords ) rotate( x, xc, sa, ca ); 
    getOrth(); // get new orthogonal projection
    if (n>4) box.rotate(dphi);
  }
   public void rotate( PVector x, PVector xc, float sa, float ca ) {
    PVector z = PVector.sub(x, xc);
    x.x = ca*z.x-sa*z.y+xc.x;
    x.y = sa*z.x+ca*z.y+xc.y;
  }
   public void rotate( PVector x, float sa, float ca ) {rotate(x,new PVector(),sa,ca);}
  
  // Move body to path=(x,y,phi)
   public void follow(PVector path) {
    PVector d = path.copy().sub(xc.copy().add(handle)); // distance to point;
    d.z = (d.z-phi);                                    // arc length to angle
    translate(d.x,d.y); rotate(d.z);                    // translate & rotate
  }
   public void follow() {
    if(pressed) follow(new PVector(window.ix(mouseX),window.iy(mouseY)));
  }
   public void follow(PVector path, PVector dpath){
    follow(path);
    dxc = new PVector(dpath.x, dpath.y);
    dphi = dpath.z;
  }
  
   public void mousePressed() {
    if (distance( mouseX, mouseY )<1) {
      pressed = true;
      handle = new PVector(window.ix(mouseX),window.iy(mouseY)).sub(xc);
    }
  }
   public void mouseReleased() {
    pressed = false;
    dxc = new PVector(); dphi = 0; // Don't include velocity
  }
   public void mouseWheel(MouseEvent event) {
    if (distance( mouseX, mouseY )<1) rotate(event.getCount()/PI/100);
  }

   public PVector pressForce ( Field p ) {
    PVector pv = new PVector(0, 0);
    for ( OrthoNormal o: orth ) {
      float pdl = p.linear( o.cen.x, o.cen.y )*o.l;
      pv.add(pdl*o.nx, pdl*o.ny, 0);
    }
    return pv;
  }
  
   public float pressMoment ( Field p ) {
    float mom = 0;
    for ( OrthoNormal o: orth ) {
      float pdl = p.linear( o.cen.x, o.cen.y )*o.l;
      mom += pdl*(o.ny*(o.cen.x-xc.x)-o.nx*(o.cen.y-xc.y));
    }
    return mom;
  }
     public float pressMomentpiv ( Field p, float pivdx, float pivdy){
    float pivmom = 0;
    for ( OrthoNormal o: orth ) {
      float pdl = p.linear( o.cen.x, o.cen.y )*o.l;
      pivmom += pdl*(o.ny*(o.cen.x-(xc.x+pivdx))-o.nx*(o.cen.y-(xc.y+pivdy)));
    }
    return pivmom;    
  }

   public float pressPower ( Field p, float dt ) {
    float power = 0;
    for ( OrthoNormal o: orth ) {
      float x = o.cen.x, y = o.cen.y,
            u = velocity( 1, dt, x, y ),
            v = velocity( 2, dt, x, y ),
            pdl = p.linear( x, y )*o.l;
      power += pdl*(u*o.nx+v*o.ny);
    }
    return power;
  }

  // compute body reaction to applied force and moment
   public void react (PVector force, float moment, float dt) {
    /* X,Y */
    if(xfree|yfree){
      // rotate to body-fixed axis
      float sa = sin(phi), ca = cos(phi);
      rotate(force,-sa,ca);
      rotate(ddotxc,-sa,ca);
      // compute acceleration (in global axis)
      ddotxc.x = (force.x+ma.x*ddotxc.x)/(mass+ma.x);
      ddotxc.y = (force.y+ma.y*ddotxc.y)/(mass+ma.y);
      rotate(ddotxc,sa,ca);
      // compute velocity and delta
      dotxc.add(ddotxc.copy().mult(dt));
      dxc = dotxc.copy().mult(dt);
      // translate
      if(!xfree) {dxc.x=0; dotxc.x=0; ddotxc.x=0;}
      if(!yfree) {dxc.y=0; dotxc.y=0; ddotxc.y=0;}
      translate(dxc.x+0.5f*ddotxc.x*sq(dt),dxc.y+0.5f*ddotxc.y*sq(dt));
    } else{
      dxc=new PVector(); dotxc=new PVector(); ddotxc=new PVector();
    }
    /* Phi */
    if(pfree){
      // compute acceleration & velocity
      ddotphi = (moment+ma.z*ddotphi)/(I0+ma.z);
      dotphi += ddotphi*dt;
      // compute delta and position
      dphi = dotphi*dt;
      rotate(dphi+0.5f*ddotphi*sq(dt));
    } else{
      dphi=0; dotphi=0; ddotphi=0;
    }
  }
   public void react (BDIM flow) {
    PVector f = pressForce(flow.p).mult(-1);
    float m = pressMoment(flow.p)*(-1);
    react(f,m,flow.dt);
  }

  // check if motion is within box limits
   public boolean check_phi_free(float m, float phi_high, float phi_low){
    return !(phi<phi_low & (m<0 | dotphi<0)) & 
           !(phi>phi_high & (m>0 | dotphi>0));
  }
   public boolean check_y_free(float fy, float y_high, float y_low){
    return !(xc.y<y_low & (fy<0 | dotxc.y<0)) & 
           !(xc.y>y_high & (fy>0 | dotxc.y>0));
  }

}
/********************************
 EllipseBody class
 
 simple elliptical body extension
 ********************************/
class EllipseBody extends Body {
  float h, a; // height and aspect ratio of ellipse
  int m = 40;

  EllipseBody( float x, float y, float _h, float _a, Window window) {
    super(x, y, window);
    h = _h; 
    a = 1.f/_a;
    float dx = 0.5f*h*a, dy = 0.5f*h;
    for ( int i=0; i<m; i++ ) {
      float theta = -TWO_PI*i/((float)m);
      add(xc.x+dx*cos(theta), xc.y+dy*sin(theta));
    }
    end(); // finalize shape

    ma = new PVector(PI*sq(dy),PI*sq(dx),0.125f*PI*sq(sq(dx)-sq(dy)));
  }
}
/* CircleBody
 simplified rotation and distance function */
class CircleBody extends EllipseBody {

  CircleBody( float x, float y, float d, Window window ) {
    super(x, y, d, 1.0f, window);
  }

   public float distance( float x, float y) {
    return mag(x-xc.x, y-xc.y)-0.5f*h;
  }

   public void rotate(float _dphi) {
    dphi = _dphi;
    phi = phi+dphi;
  }
  
}
/********************************
BodyUnion class

This class combines an array of body instances by a union operator
which `adds` bodies to the flow. If two bodies are given, they are added
automatically. Bodies can also be 'add'ed individually. 

Other operations are possible but haven't been coded up yet.

SaveArray is a writer class that outputs all the values for the array 
in one line. At this point, only the pressure forces have been coded.

Example code:

BodyUnion body;
void setup(){
  size(400,400);
  Window view = new Window(100,100);
  body = new BodyUnion( new NACA(30,30,20,0.2,view),
                        new CircleBody(70,30,15,view));
  body.add(new CircleBody(30,70,15,view));
}
void draw(){
  background(0);
  body.follow(); // uncomment to move as a group
  //for (Body child : body.bodyList) child.follow(); // uncomment to move individually
  body.display();
}
void mousePressed(){body.mousePressed();}
void mouseReleased(){body.mouseReleased();}
********************************/
class BodyUnion extends Body{
  ArrayList<Body> bodyList = new ArrayList<Body>();  //This is a container for all bodies

  BodyUnion(float x, float y, Window window){ 
    super(x, y, window);
  }

  BodyUnion(Body a, Body b){
    super(a.xc.x,a.xc.y,a.window);
    add(a); add(b);
  }

  BodyUnion(Body a, Body b ,Body c){
    super(a.xc.x,a.xc.y,a.window);
    add(a); add(b);add(c);
  }
  
   public void add(Body body){
    bodyList.add(body);
    area += body.area;
  }
  
   public void recenter(){
    xc = new PVector(); 
    for (Body b : bodyList){xc.add(b.xc.copy().mult(b.area));}
    xc = xc.div(area);
  }
   public void recenter(float x, float y){xc = new PVector(x,y);}
  
   public void display(int C, Window window ){
    for ( Body body : bodyList ){
        body.display(C, window); //<>// //<>// //<>// //<>//
    }
  }
  
   public float distance(float x, float y){
    float d = 1e6f;
    for ( Body body : bodyList )
      d = min(d,body.distance(x,y));
    return d;
  }  
  
   public PVector WallNormal(float x, float y){
    float w[] = get_weights(x,y);
    PVector m = new PVector(0,0);
    for ( int i = 0; i<bodyList.size(); i++ ) {
      PVector n = bodyList.get(i).WallNormal(x,y);
      m.add(n.mult(w[i]));
    }
    return m;
  }
  
   public float velocity( int d, float dt, float x, float y ){
    float w[] = get_weights(x,y);
    float v = 0;
    for ( int i = 0; i<bodyList.size(); i++ ) {
      float u = bodyList.get(i).velocity(d,dt,x,y);
      v += u*w[i];
    }
    return v;
  }

   public void translate(float dx, float dy){
    xc.add(new PVector(dx, dy));
    for (Body body : bodyList) body.translate(dx,dy);
  }
   public void rotate(float dphi){ // rotate around _union_ xc
    float sa = sin(dphi), ca = cos(dphi)-1;
    phi = phi+dphi;
    for (Body body : bodyList){
      PVector z = PVector.sub(body.xc,xc);
      float dx = ca*z.x-sa*z.y;
      float dy = sa*z.x+ca*z.y;
      body.translate(dx,dy);
      body.rotate(dphi);
    }
  }
   public void initPath(PVector p){
    follow(p);
    for (Body body : bodyList) {
      body.dxc = new PVector(); body.dphi = 0;
    }
  }

   public boolean unsteady(){ 
    boolean unsteady = false;
    for (Body body : bodyList){
      unsteady = unsteady | body.unsteady();
    }
    return unsteady;
  }

   public void react(BDIM flow){
    for (Body body : bodyList) body.react(flow);
  }
   public void react(PVector f, float m, float dt){
    for (Body body : bodyList) body.react(f,m,dt);
  }

   public void mousePressed(){
    super.mousePressed();
    for (Body body : bodyList){body.mousePressed();}
  }  
   public void mouseReleased(){
    super.mouseReleased();
    for (Body body : bodyList){body.mouseReleased();}
  }
   public void mouseWheel(MouseEvent event){
    super.mouseWheel(event);
    for (Body body : bodyList){body.mouseWheel(event);}
  }

// weight the body influences at point x,y
   public float[] get_weights(float x, float y){
    int n = bodyList.size();
    float s=0, weights[]=new float[n];
    for ( int i = 0; i<n; i++ ){
      float d = bodyList.get(i).distance(x,y);
      weights[i] = delta0(-d/3.f); // kernel weight
      s += weights[i];
    }
    for ( int i = 0; i<n & s>0; i++) 
        weights[i] /= s;          // normalize weights
    return weights;
  }
  
   public float delta0( float d ){
    if( d <= -1 ){
      return 0;
    } else if( d >= 1 ){
      return 1;
    } else{
      return 0.5f*(1.f+d+sin(PI*d)/PI);
    } 
  }
}

// Save values on an array of bodies

class SaveArray{
  PrintWriter output;
  
  SaveArray(String name){
    output = createWriter(name);
  }
  
   public void printPressForce(Field pressure, BodyUnion bodies, float L){
    for(Body body: bodies.bodyList){
        PVector force = body.pressForce(pressure);
        output.print(2.f*force.x/L+" "+2.f*force.y/L+" ");
    }
    output.println();
  }

   public void close(){
    output.close(); // Finishes the file
  }  
}
/**********************************
 CirculationFinder class
 
 Finds and displays circulation of vortices in the wake.
 Algorithm: 
 1) Finds local peaks in vorticity field, labelling them as circular cores
 2a) Grows the cores until the vorticity at the border dies out
 2b) If cores of the same sign interefere with each other, core with less circulation is removed (as defined a rough circulation estimate)
 3) Finds final circulation by adding the vorticity within the core; however, only adds the vorticity of a single sign
 example code:
 
 BDIM flow;
 Body body;
 FloodPlot flood;
 CirculationFinder cf;
 
 void setup(){
   int n=(int)pow(2,7);
   float d = n/12;
   size(800,400);
   Window view = new Window(n,n/2);
 
   body = new CircleBody(n/4,n/4,d,view);
   flow = new BDIM(n,n/2,1.5,body);
 
   cf = new CirculationFinder(flow,body,view);
   cf.setAnnotate(true,1.0/d);
 
   flood = new FloodPlot(view);
   flood.setLegend("vorticity",-0.5,0.5);
 }
 void draw(){
   flow.update();flow.update2();
   cf.update();
 
   flood.display(flow.u.curl());
   body.display();
   cf.display();
 }
 ***********************************/

class CirculationFinder {
  ArrayList<VortexCore> cores = new ArrayList(1024);
  ArrayList<VortexCore> toremove = new ArrayList(1024);
  Window window;
  Field vorticity;
  float circres=8, r_init=1, dr=2, r_max;
  BDIM flow;
  Body body;

  float Qmin, wmin, bmin, diatol, annoscale = 1;
  boolean dispG=true;

  CirculationFinder(BDIM flow, Body body, Window window) {
    this.flow = flow;
    this.body = body;
    this.window = window;
    setParams(0.01f, 0.01f, 5, 0.05f);
    r_max = 0.25f*window.dy;
  }
   public void setParams(float Qmin, float wmin, float bmin, float diatol) {
    this.Qmin = Qmin; //Minimum Qcriterion to be considered a core
    this.wmin = wmin; //Minimum vorticity in center to be considered a core
    this.bmin = bmin; //Minimum distance from body
    this.diatol = diatol; //Tolerance on vorticity reaching asymtote as the core diameter increases, as a fraction of center vorticity
  }
   public void setAnnotate(boolean dispG, float s) {
    this.dispG=dispG; //Display circulation value
    this.annoscale=s;  //Display scaling of circulation values
  }
   public void update() {
    //Updates the vortex cores

    // +++++++++++++++ Step 1 - Finds local maxima in vorticity that also satisfy requirements of minimum vorticity, Qcriterion, and distance from body
    vorticity = flow.u.curl();
    float[][] w = vorticity.a;
    cores.clear();
    for ( int i=1 ; i<flow.n-1 ; i++ ) {
      for ( int j=1 ; j<flow.m-1 ; j++ ) {
        //Find local peaks
        if ((w[i+1][j] < w[i][j] && w[i-1][j] < w[i][j] && w[i][j+1] < w[i][j] && w[i+1][j-1] < w[i][j]) || (w[i+1][j] > w[i][j] && w[i-1][j] > w[i][j] && w[i][j+1] > w[i][j] && w[i+1][j-1] > w[i][j])) {
          if (Qcrit(i, j, flow.u)>Qmin && abs(w[i][j])>wmin && body.distance((float)i, (float)j)>bmin) { //Check for Q criterion, max vorticity, and distance from body
            cores.add(new VortexCore(i, j, r_init, w[i][j])); //Add a new vortex core
          }
        }
      }
    }
    println("Number of Valid Peaks: " + cores.size());

    // +++++++++++++++ Step 2 - Expands all the cores until either they interefere with each other, or the vorticity dies out
    boolean running=true; //indicator that all cores have finished dilating
    while (running) {
      running = false;

      //Dilate all the cores, but only if the vorticity on the border is above a threshold
      for (VortexCore c : cores) {
        float meanborderw = lineinteg(c.xc, c.r, vorticity, true)/(2*PI*c.r); //Find mean of vorticity along perimeter
        if ((abs(meanborderw)>diatol*abs(c.w))) { //Check if mean vorticity along perimeter is greater than a small fraction of max vorticity
          if ((c.r<r_max)&&(c.r<body.distance(c.xc.x, c.xc.y)-dr)) { //Check if radius is too big or interferes with body
            //Dilate the given core, and reset indicator
            running = true;
            c.G_rough += meanborderw*(2*PI*c.r)*dr; //Rough circulation found iteratively, used to compare strength of vorticies
            c.r += dr;
          }
        }
      }

      //Check for core interference with other cores
      toremove.clear();
      for (int i=cores.size()-1; i>=0; i--) {
        VortexCore ci = cores.get(i);
        for (int j=i-1; j>=0; j--) {
          VortexCore cj = cores.get(j);
          //Check for interference between cores
          if ((PVector.sub(ci.xc, cj.xc).mag()<(ci.r+cj.r+2*dr)) && (cj.w*ci.w>0)) {       
            //Remove core with smaller rough circulation if same sign
            if (abs(ci.G_rough)>abs(cj.G_rough))
              toremove.add(cj);
            else
              toremove.add(ci);
          }
        }
      }
      cores.removeAll(toremove);
    }

    //+++++++++++++++ Step 3 - Find final circulation again by area method, ignoring vorticity of the wrong sign
    for (VortexCore c: cores)
      c.G = areainteg(c.xc, c.r, vorticity, true);
    println("Final Number of Cores: " + cores.size());
  }
   public void display() {
    //Displays the vortex cores, and labels the circulation if specified
    int G = 0xFF000393, S = 0xFF0003A3, w = 0xFF0003C9, txtpnt = 12;
    PImage img = copy();
    img.loadPixels();
    if (cores.size()>0) {
      for ( VortexCore c: cores ) {
        stroke(img.pixels[window.px(c.xc.x)+window.py(c.xc.y)*img.width]);
        fill(0, 0);
        dashcirc(c.xc.x, c.xc.y, c.r, round(c.r*2), window);
        if (dispG) {
          textSize(txtpnt);
          textAlign(CENTER, TOP);
          fill(0);
          char sign = '+';
          if (c.G<0)
            sign = '-';
          text("" + (char)S + (char)w + sign + ": " + nfs(c.G*annoscale, 1, 2), window.px(c.xc.x), window.py(c.xc.y+c.r));
        }
      }
    }
  }
   public void dashcirc(float x0, float y0, float r, int n, Window window) {
    //Draws a dashed circle at (x0,y0) with radius 'r' and 'n' dashes
    float x1, y1, x2, y2;
    for (float i=0; i<2*n-1; i+=2) {
      x1 = r*cos(PI*i/n)+x0;
      y1 = r*sin(PI*i/n)+y0;
      x2 = r*cos(PI*(i+1)/n)+x0;
      y2 = r*sin(PI*(i+1)/n)+y0;
      line(window.px(x1), window.py(y1), window.px(x2), window.py(y2));
    }
  }
   public float lineinteg(PVector xc, float r, VectorField u) {
    //Finds line integral about a circle, integral of u-dot-ds
    int n = round(r*circres);
    float res=0, x, y, dx, dy, dth = 2*PI/n;
    if (r<0)
      return 0;
    for (int i=0; i<n; i++) {
      x = r*cos(i*dth);
      y = r*sin(i*dth);
      dx = x-r*cos((i-1)*dth);
      dy = y-r*sin((i-1)*dth);
      res += u.x.linear(xc.x+x, xc.y+y)*dx + u.y.linear(xc.x+x, xc.y+y)*dy;
    }
    return res;
  }
   public float lineinteg(PVector xc, float r, Field F, boolean sum_only_same_sign) {
    //Finds line integral about a circle, integral of Fds
    float n = round(r*circres);
    float res=0, x, y, dth = 2*PI/n, Fds;
    float Fmid = F.linear(xc.x, xc.y);
    if (r<0) {
      return 0;
    }
    for (int i=0; i<n; i++) {
      x = r*cos(i*dth);
      y = r*sin(i*dth);
      Fds = F.linear(xc.x+x, xc.y+y)*r*dth;
      if (!sum_only_same_sign || (Fds*Fmid>0 && sum_only_same_sign))
        res += Fds;
    }
    return res;
  }
   public float areainteg(PVector xc, float R, Field F, boolean sum_only_same_sign) {
    //Finds area integral on the inside of a circle, integral of FdA, using concentric circles
    float res=0, x, y, n, dth, r1, r2, FdA, Fmid; 
    if (R<0)
      return 0;
    Fmid = F.linear(xc.x, xc.y)*PI*dr*dr/4.0f;
    for (float r=1; r<=R; r+=dr) {
      n = round(r*circres);
      r2 = r+dr/2; 
      r1 = r-dr/2;
      if (r==R)
        r2 = R;
      dth = 2*PI/n;
      for (int i=0; i<n; i++) {
        x = r*cos(i*dth);
        y = r*sin(i*dth);
        FdA = F.linear(xc.x+x, xc.y+y)*(r2*r2-r1*r1)*dth/2.0f;
        if (!sum_only_same_sign || (FdA*Fmid>0 && sum_only_same_sign))
          res += FdA;
      }
    }
    return res+Fmid;
  }
   public float Qcrit(int i, int j, VectorField velo) {
    //Finds Qcriterion of flow at location (i,j)
    if ((i-1<0)||(j-1<0)||(i+1>velo.n-1)||(j+1>velo.m-1))
      return 0;
    float[][] u = velo.x.a;
    float[][] v = velo.y.a;
    float dudx = 0.5f*(u[i+1][j]-u[i-1][j]);
    float dudy = 0.5f*(u[i][j+1]-u[i][j-1]);
    float dvdx = 0.5f*(v[i+1][j]-v[i-1][j]);
    float dvdy = 0.5f*(v[i][j+1]-v[i][j-1]);
    return dudx*dvdy-dvdx*dudy;
  }
}
class VortexCore {
  //Vortex Core object, has two circulations 'G' and 'G_rough' (area integral of vorticity and a rough estimate used to compare vortex strengths)
  //Also has a center 'xc', radius 'r', vorticity at center 'w'
  float G_rough, G, r, w;
  PVector xc;
  boolean grow;
  VortexCore(float x, float y, float r, float w, float Gv, float G) {
    this.xc = new PVector(x, y, 0);
    this.r = r;
    this.w = w;
    this.G_rough = G;
    this.G = G;
    this.grow = true;
  }
  VortexCore(float x, float y, float r, float w) {
    this(x, y, r, w, 0, 0);
  }
  VortexCore(PVector xc, float r, float w) {
    this(xc.x, xc.y, r, w, 0, 0);
  }
}
/**********************************
Field class

Holds the values and operators for a
fluid dynamics field

example code:
Field p,u,v;

void setup(){
  size(400,400);
  background(1,0,0);
  p = new Field(100,150);
  p.eq(1.0,40,50,40,75);
  u = new Field(100,150,1,0.25);
  v = new Field(100,150,2,0.2);
}
void draw(){
  p.advect( 1., u, v );
  p.display(0,1);
}
***********************************/

class Field{
  float[][] a;  
  int n,m,btype=0;
  float bval=0;
  boolean gradientExit=false;
  
  Field( int n, int m, int btype, float bval ){
    this.n = n;
    this.m = m;
    this.a = new float[n][m];
    this.btype = btype;
    this.bval = bval;
    this.eq(bval);
  }
  Field( int n, int m){this(n,m,0,0);}

  Field( Field b, int is, int n, int js, int m ){
    this.n = n;
    this.m = m;
    a = new float[n][m];
    btype = b.btype;
    bval = b.bval;
    for( int i=0; i<n; i++){
    for( int j=0; j<m; j++){
      a[i][j] = b.a[i+is][j+js];
    }}
  }
  Field( Field b ){
    n = b.n;
    m = b.m;
    a = new float[n][m];
    btype = b.btype;
    bval = b.bval;
    this.eq(b);
  }

   public Field laplacian (){
    Field d = new Field( n, m ); 
    d.btype = btype;
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      d.a[i][j] = -4*a[i][j]+a[i+1][j]
        +a[i-1][j]+a[i][j+1]+a[i][j-1];
    }}
    return d;
  }

   public VectorField gradient(){
    mismatch(btype,0);
    VectorField g = new VectorField(n,m,0,0);
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      g.x.a[i][j] = a[i][j]-a[i-1][j];
      g.y.a[i][j] = a[i][j]-a[i][j-1];
    }}
    g.setBC(); // issues?
    return g;
  }
  
   public VectorField curl (){
    // returns curl{this \hat z}
    mismatch(btype,3);
    VectorField g = new VectorField(n,m,0,0);
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      g.x.a[i][j] = a[i][j+1]-a[i][j];
      g.y.a[i][j] = a[i][j]-a[i+1][j];
    }}
    return g;
  }

   public void advect( float step, VectorField u, VectorField u0 ){
    advect( step, u.x, u.y, u0.x, u0.y );
  }
   public void advect( float step, Field u, Field v, Field u0, Field v0 ){
    /* advect the field with the u,v velocity field
       here we use a first order lagrangian method
         Da/Dt = 0
         a(t=dt,x,y) = a(t=0,x-dt*u(x,y),y-dt*v(x,y))
       the example code shows how diffusive this is 
       EDIT: by using an RK2 step to find x0 and using
       a quadratic interpolation, this method is second
       order and nondiffuse.
       EDIT2: by treating the old and new velocities 
       seperately, the method is second order in time.*/
    Field a0 = new Field(this);
    for( int i=1; i<n-1; i++){
      for( int j=1; j<m-1; j++){
        float x = i;
        float y = j;
        if(btype==1) x -= 0.5f;
        if(btype==2) y -= 0.5f;
        float ax = -step*u.linear( x, y );
        float ay = -step*v.linear( x, y );
        float bx = -step*u0.linear( x+ax, y+ay );
        float by = -step*v0.linear( x+ax, y+ay );
        a[i][j] = a0.quadratic( x+0.5f*(ax+bx), y+0.5f*(ay+by) );
      }
    }
    setBC();
  }
   public void advect( float step, VectorField u ){
    advect( step, u.x, u.y );
  }
   public void advect( float step, Field u, Field v){
    /* advect the field with the u,v velocity field
       here we use a first order lagrangian method
         Da/Dt = 0
         a(t=dt,x,y) = a(t=0,x-dt*u(x,y),y-dt*v(x,y))
       the example code shows how diffusive this is 
       EDIT: by using an RK2 step to find x0 and using
       a quadratic interpolation, this method is second
       order and nondiffuse.
       EDIT2: RK2 step is not needed for first step
       in time accurate soln.*/
    Field a0 = new Field(this);
    for( int i=1; i<n-1; i++){
      for( int j=1; j<m-1; j++){
        float x = i;
        float y = j;
        if(btype==1|btype==3) x -= 0.5f;
        if(btype==2|btype==3) y -= 0.5f;
        float ax = -step*u.linear( x, y );
        float ay = -step*v.linear( x, y );
        a[i][j] = a0.quadratic( x+ax, y+ay );
      }
    }
    setBC();
  }

   public float quadratic( float x0, float y0){
    float x = x0, y = y0;
    if(btype==1|btype==3) x += 0.5f;
    if(btype==2|btype==3) y += 0.5f;
    int i = round(x), j = round(y);
    if( i>n-2 || i<1 || j>m-2 || j<1 )
      return linear( x0, y0 );
    x -= i; y -= j;
    float e = quadratic1D(x,a[i-1][j-1],a[i][j-1],a[i+1][j-1]);
    float f = quadratic1D(x,a[i-1][j  ],a[i][j  ],a[i+1][j  ]);
    float g = quadratic1D(x,a[i-1][j+1],a[i][j+1],a[i+1][j+1]);
    return quadratic1D(y,e,f,g);
  }
   public float quadratic1D(float x, float e, float f, float g){
    float x2 = x*x;
    float fx = f*(1.f-x2);
    fx += (g*(x2+x)+e*(x2-x))*0.5f;
    fx = min(fx,max(e,f,g));
    fx = max(fx,min(e,f,g));
    return fx;
  }  
   public float linear( float x0, float y0 ){
    float x  = min(max(0.5f,x0), n-1.5f);
    if(btype==1|btype==3) x += 0.5f;
    int i = min( (int)x, n-2 ); 
    float s = x-i;
    float y  = min(max(0.5f,y0), m-1.5f);
    if(btype==2|btype==3) y += 0.5f;
    int j = min( (int)y, m-2 );
    float t = y-j;
    if(s==0 && t==0){
      return a[i][j];
    }else{
      return s*(t*a[i+1][j+1]+(1-t)*a[i+1][j])+
         (1-s)*(t*a[i  ][j+1]+(1-t)*a[i  ][j]);
    }
  }
   public float interp( float x0, float y0 ){return linear(x0,y0);}
  
   public void display( float low, float high ){
    PImage img = createImage(n-2,m-2,RGB);
    img.loadPixels();
    for ( int i=0 ; i<n-2 ; i++ ) {
      for ( int j=0 ; j<m-2 ; j++ ) {
        float f = a[i+1][j+1];
        int k = i+j*(n-2);
        f = map(f,low,high,0,255);
        img.pixels[k] = color(f);
      }
    }
    img.updatePixels();
    int x0 = width/(n-2), y0 = height/(m-2);
    image(img,x0,y0,width,height);
  }

   public void setBC (){
    float s=0;
    for (int j=0 ; j<m ; j++ ) {  
      a[0][j]   = a[1][j];  
      a[n-1][j] = a[n-2][j];      
      if(btype==1){
        if(gradientExit){
          a[1][j]   = bval;  
          if(j>0 & j<m-1) s += a[n-1][j];          
        } else {
          a[1][j]   = bval;  
          a[n-1][j] = bval;
    }}}
    for (int i=0 ; i<n ; i++ ) {  
      a[i][0]   = a[i][1];
      a[i][m-1] = a[i][m-2];
      if(btype==2){
        a[i][1]   = bval;  
        a[i][m-1] = bval;
      }   
    }
    if(gradientExit){
      s /= PApplet.parseFloat(m-2);
      for( int j=1; j<m-1; j++ ) a[n-1][j] += bval-s;
    }
  }
  
   public Field normalGrad(VectorField wnx, VectorField wny){
    Field g = new Field(n,m,0,0);
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      g.a[i][j] = 0.5f*(wnx.x.a[i][j]*(a[i+1][j]-a[i-1][j])+wny.x.a[i][j]*(a[i][j+1]-a[i][j-1]));
    }}
    return g;
  }

   public Field times( float b ){
    Field c = new Field(this);
    for( int i=0; i<n; i++){
    for( int j=0; j<m; j++){
        c.a[i][j] *= b;
    }}
    return c;
  }
   public Field times( Field b ){
    mismatch(this.btype,b.btype); 
    Field c = new Field(this);
    for( int i=0; i<n; i++){
    for( int j=0; j<m; j++){
      c.a[i][j] *= b.a[i][j];
    }}
    return c;
  }
   public void timesEq( float b ){ eq(times(b)); }
   public void timesEq( Field b ){ eq(times(b)); }
   public Field plus( float b ){
    Field c = new Field(this);
    for( int i=0; i<n; i++){
    for( int j=0; j<m; j++){
      c.a[i][j] += b;
    }}
    return c;
  }
   public Field plus( Field b ){
    mismatch(this.btype,b.btype); 
    Field c = new Field(this);
    for( int i=0; i<n; i++){
    for( int j=0; j<m; j++){
      c.a[i][j] += b.a[i][j];
    }}
    return c;
  }
   public void plusEq( Field b ){ eq(plus(b)); }
   public void plusEq( float b ){ eq(plus(b)); }
   public Field minus( Field b ){
    mismatch(this.btype,b.btype); 
    Field c = new Field(this);
    for( int i=0; i<n; i++){
    for( int j=0; j<m; j++){
      c.a[i][j] -= b.a[i][j];
    }}
    return c;
  }
   public void minusEq( Field b ){ eq(minus(b)); }
   public Field inv(){
    Field c = new Field(this);
    for( int i=0; i<n; i++){
    for( int j=0; j<m; j++){
      c.a[i][j] = 1.f/c.a[i][j];
    }}
    return c;
  }
   public void invEq(){ eq(inv()); }
   public float inner( Field b ){
    mismatch(this.btype,b.btype); 
    double s = 0;
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      s += a[i][j]*b.a[i][j];
    }} 
    return (float)s;
  }
   public float sum(){
    float s = 0;
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      s += a[i][j];
    }} 
    return s;
  }
   public void eq( float b ,int is, int ie, int js, int je){
    for( int i=is; i<ie; i++){
    for( int j=js; j<je; j++){
      a[i][j] = b;
    }}
  }
   public void eq( float b){eq(b,0,n,0,m);}
   public void eq( Field b){
    for( int i=0; i<n; i++){
    for( int j=0; j<m; j++){
      a[i][j] = b.a[i][j];
    }}
  }
  
   public void mismatch(int i, int j){
    if(i!=j){
      println("You can't add or multiple fields of different types.");
      exit();
    }     
  }
  
   public float L_inf(){
    float mx = 0;
    for( int i=0; i<n; i++){
    for( int j=0; j<m; j++){
      mx = max(mx,abs(a[i][j]));
    }}
    return mx;
  }
}
/**********************************
 FloodPlot class
 
 Holds the values and operators for
 very nice flood plots
 
 example code:
void setup(){
  size(400,400);
  int n=100,m=2;
//  FloodPlot plot = new FloodPlot(new Window(1,1,n-2,m-2,100,1,300,325)); //custom window
  FloodPlot plot = new FloodPlot(new Window(n,m)); // standard window
  Field p = new Field(n,m);
  for( int i=0; i<n; i++){
  for( int j=0; j<m; j++){
    p.a[i][j] = 1.5*(0.5-i/(float)(n-1));
  }}
  plot.range = new Scale(-1,1);
  plot.hue = new Scale(200,140);
  plot.setLegend("test");
  plot.display(p);
}
***********************************/
 
class FloodPlot{
  LegendPlot legend;
  PImage img;
  Window window;
  Scale range = new Scale(0,1);
  Scale hue = new Scale(240,0);
  Scale sat = new Scale(1,1);
  Scale bri = new Scale(1,1);
  boolean sequential=false,legendOn=false,dark=false,sharp=false;

  FloodPlot( Window window, String title, float low, float high ){
    this.window = window;
    img = new PImage(window.dx,window.dy,HSB);
    setLegend(title, low, high);
  }
  FloodPlot( Window window ){
    this.window = window;
    img = new PImage(window.dx,window.dy,HSB);
  }
  FloodPlot( FloodPlot a){
    legend = a.legend; 
    img = a.img; 
    window = a.window;
    range = a.range; 
    hue = a.hue; sat = a.sat; bri = a.bri;
    sequential = a.sequential; 
    legendOn = a.legendOn; dark = a.dark; sharp = a.sharp;
  }

   public int colorScale( float f ){
    float i = range.in(f); // get % of the range
    if( sharp & i>0.4f & i<0.6f ) i = 0.5f;
    if(sequential){          // blend hue and saturation
      return color(hue.outB(i),sat.out(i),bri.out(i));
    } 
    else if(i<0.5f) {       // blend from low end to black/white
      if (dark) {return color(hue.outS,sat.outS,1-2*i);}
      else {return color(hue.outS,(0.5f-i)*2,1);}
    } 
    else {                 // blend from high end to black/white
      if (dark) {return color(hue.outE,sat.outE,2*i-1);}
      else {return color(hue.outE,(i-0.5f)*2,1);}
    }
  } 

   public void display ( Field a ){
    float minv = 1e6f, maxv = -1e6f;
    colorMode(HSB,360,1.0f,1.0f,1.0f);
    noStroke();
    img.loadPixels();
    for ( int i=0 ; i<window.dx ; i++ ) {
      float x = window.ix(i+window.x0);
      for ( int j=0 ; j<window.dy ; j++ ) {
        float y = window.iy(j+window.y0);
        float f = a.interp(x,y);
        img.pixels[i+j*window.dx] = colorScale(f);
        minv = min(minv,f);
        maxv = max(maxv,f);
      }
    }
    img.updatePixels();
    image(img,window.x0,window.y0);
    if(legendOn) legend.display(minv,maxv);
  }

   public void setLegend(String title, float low, float high){
    range = new Scale(low,high);
    legend = new LegendPlot(this,title);
    legendOn = true;
  }
   public void setLegend(String title){ setLegend( title, range.outS, range.outE );}

   public void setColorMode(int mode){
    if (mode==1){dark = false;}
    if (mode==2){sequential = true;}
    if (mode==3){sequential = true; sat = new Scale(0,0); bri = new Scale(0,1);}
    if (mode==4){sequential = true; sat = new Scale(1,0); bri = new Scale(0.24f,1); hue.outE = hue.outS; hue.r = 0;}
    if (legendOn){legend.setColorMode(mode);}
  }

  class LegendPlot extends FloodPlot{
    String title;
    Field levels;
    boolean box = false;

    LegendPlot( FloodPlot a, String _title){
      super(a); legendOn = false; // duplicate the flood settings, except for legend

      int n = 11, m = 2; // resize the window and image
      window = new Window(1,1,n-2,m-2,a.window.x0+a.window.dx/4,a.window.y0+14,a.window.dx/2,16);
      img = new PImage(window.dx,window.dy);

      title = _title;

      levels = new Field(n,m);  // generate data to plot
      for (int i=0; i<n; i++){
        for (int j=0; j<m; j++){
          levels.a[i][j] = range.out(i/PApplet.parseFloat(n-1));
        }
      }
    }
     public void display( float minv, float maxv ){
      if(box) {
        noStroke(); fill(colorScale(0));
        rect(0,0,width,45);
      }

      super.display(levels);

      int x0 = window.x0, x1 = window.x0+window.dx;
      int y0 = window.y0, y1 = window.y0+window.dy;
      float low = range.outS, high = range.outE;
      Scale x = new Scale(low,high,x0,x1);

      textSize(15);
      fill((sequential |!dark )?0:360);
      textAlign(RIGHT,CENTER);
      text(title,x0,0.5f*(y0+y1));
      textAlign(CENTER,BASELINE);
      text(""+low,x0,y0);
      text(""+high,x1,y0);
      if(low<0&&high>0)text("0",x.out(0),y0);
      textAlign(CENTER,TOP);
      stroke(0);
      fill(colorScale(minv));
      text(nf(minv,ceil(log(abs(minv))/log(10)),2),x.out(minv),y1);
      fill(colorScale(maxv));
      text(nf(maxv,ceil(log(abs(maxv))/log(10)),2),x.out(maxv),y1);
    }
  }
  
       public void displayTime(float t){
      int x0 = window.x0, x1 = window.x0+window.dx;
      int y0 = window.y0, y1 = window.y0+window.dy;
      textAlign(CENTER,BASELINE);
      fill(255);
      text("t = "+ nfs(t,2,2),0.5f*(x0+x1),y1);
    }
}
/**********************************
MG (MultiGrid) class

Sets up a PossionMatrix problem and solves with MG

Example code:

MG solver;
void setup(){
  size(512,512);
  noStroke();
  frameRate(.5);
  int N = 128+2;                               // <-Try changing the number of points
  VectorField u = new VectorField(N,N,1,-0.5);
  u.x.eq(0.,40,50,40,75);                      // Create divergent velocity field
  VectorField c = new VectorField(N,N,0,0);
  c.x.eq(1); c.y.eq(1); c.setBC();
  solver = new MG( new PoissonMatrix(c), new Field(N,N), u.divergence() );
  println(solver.tol);                          //  <- note dependance on N
}
void draw(){
  solver.update();                             // Do one solver iteration
  solver.r.display(-1e-5,1e-5);                // Visualize the residual
  println("ratio:"+solver.r.inner(solver.r)/solver.tol+", inf:"+solver.r.L_inf());
  if(solver.r.L_inf()<1e-5) noLoop();
}

 ***********************************/

 public Field MGsolver( float itmx, PoissonMatrix A, Field x, Field b ) {
  MG solver = new MG( A, x, b);
  while (solver.iter<itmx) {
    solver.update();
    if (solver.r.inner(solver.r)<solver.tol) break;
  }
  println("residual: "+solver.r.L_inf()+", iter: "+solver.iter);
  return solver.x;
}

class MG {
  PoissonMatrix A;
  Field r, x, d;
  int iter=0, level=0, its=4;
  float tol=1e-4f;

  MG( PoissonMatrix A, Field x, Field b ) {
    this.A = A;
    this.x = x;
    r = new Field(x.n, x.m, 0, tol);
    tol = r.inner(r);
    r = A.residual(b, x);
  }
  MG( PoissonMatrix A, Field r, int level, int iter ) {
    this.A = A;
    this.r = r;
    x = new Field(r.n, r.m);
    this.level = level;
    this.iter = iter;
  }

   public void update() {
    iter++;
    //println("  iter:"+iter);
    vCycle();
    smooth(its);
  }

   public void vCycle() { // recursive MG V-cycle
    smooth(0);
    MG coarse = new MG(restrict(A), restrict(r), level+1, iter);
    //println("  level:"+level+"->"+coarse.level);
    if (coarse.divisible()) coarse.vCycle();
    coarse.smooth(its);
    //println("  level:"+coarse.level+"->"+level);
    d = prolongate(coarse.x);
    increment();
  }

   public void smooth( int itmx ){
    d = r.times(A.inv);
    for( int it=0 ; it<itmx ; it++ ){
    for( int i=1 ; i<r.n-1 ; i++ )  {
    for( int j=1 ; j<r.m-1 ; j++ )  {
      d.a[i][j] = -(d.a[i-1][j]*A.lower.x.a[i][j]
                   +d.a[i+1][j]*A.lower.x.a[i+1][j]
                   +d.a[i][j-1]*A.lower.y.a[i][j]
                   +d.a[i][j+1]*A.lower.y.a[i][j+1]
                   -r.a[i][j])*A.inv.a[i][j];
    }}}
    d.setBC();
    increment();
  }

   public void increment() {
    x.plusEq(d);
    r.minusEq(A.times(d));
  }

   public boolean divisible() {
    boolean flag = (x.n-2)%2==0 && (x.m-2)%2==0 && x.n>4 && x.m>4;
    if ( !flag && x.n>9 && x.m>9 ) {
      println("MultiGrid requires the size in each direction be a large factor of two (2^p) times a small number (N=1..9).");
      exit();
    }
    return flag;
  }

   public PoissonMatrix restrict( PoissonMatrix A ) {
    int n = (A.lower.n-2)/2+2;
    int m = (A.lower.m-2)/2+2;
    VectorField lower = new VectorField(n, m, 0, 0);
    for ( int i=1; i<n-1; i++ ) {
      for ( int j=1; j<m-1; j++ ) {
        int ii = (i-1)*2+1;
        int jj = (j-1)*2+1;
        lower.x.a[i][j] = (A.lower.x.a[ii][jj]+A.lower.x.a[ii][jj+1])*0.5f;
        lower.y.a[i][j] = (A.lower.y.a[ii][jj]+A.lower.y.a[ii+1][jj])*0.5f;
      }
    }
    lower.setBC();
    return new PoissonMatrix(lower);
  }

   public Field restrict( Field a ) {
    int n = (a.n-2)/2+2;
    int m = (a.m-2)/2+2;
    Field b = new Field(n, m);
    for ( int i=1; i<n-1; i++ ) {
      for ( int j=1; j<m-1; j++ ) {
        int ii = (i-1)*2+1;
        int jj = (j-1)*2+1;
        b.a[i][j] = a.a[ii][jj]+a.a[ii][jj+1]+a.a[ii+1][jj]+a.a[ii+1][jj+1];
      }
    }
    b.setBC();
    return b;
  }

   public Field prolongate( Field a ) {
    int n = (a.n-2)*2+2;
    int m = (a.m-2)*2+2;
    Field b = new Field(n, m);
    for ( int i=0; i<n; i++ ) {
      for ( int j=0; j<m; j++ ) {
        int ii = (i-1)/2+1;
        int jj = (j-1)/2+1;
        b.a[i][j] = a.a[ii][jj];
      }
    }
    b.setBC();
    return b;
  }
}
/********************************
NACA airfoil class

example code:

NACA foil;
void setup(){
  size(400,400);
  foil = new NACA(1,1,0.5,0.20,new Window(3,3));
}
void draw(){
  background(0);
  foil.display();
  foil.rotate(0.01);
}
********************************/
class NACA extends Body{
  int m = 100;
  float c, FoilArea;
  float pivot;
  
  NACA( float x, float y, float c, float t, float pivot, Window window ){
    super(x,y,window);
    add(xc.x-c*pivot,xc.y);
    for( int i=1; i<m; i++ ){
      float xx = pow(i/(float)m,2);
      add(xc.x+c*(xx-pivot),xc.y+t*c*offset(xx));      
    }
    add(xc.x+c*(1-pivot),xc.y);
    for( int i=m-1; i>0; i-- ){
      float xx = pow(i/(float)m,2);
      add(xc.x+c*(xx-pivot),xc.y-t*c*offset(xx));
    }
    end(); // finalizes shape
    this.c = c;
    FoilArea = t*c*0.685084f;    //crossectional area of NACA foil
    
    float dx = c/2, dy = t*c/2;
    ma = new PVector(PI*sq(dy),PI*sq(dx),0.125f*PI*sq(sq(dx)-sq(dy)));
    ma.z += sq(c*(0.5f-pivot))*ma.y;
  }
  
  NACA( float x, float y, float c, float t, Window window ){
    //this(x,y,c,t,0.25,window);
    this(x,y,c,t,0,window); // centre postion
  }
  
   public float[][] interp( Field a ){
    float[][] b = new float[2][m+1];

    PVector x = coords.get(0);
    b[0][0] = a.interp(x.x,x.y); b[1][0] = b[0][0];
    for ( int i = 1; i<m; i++ ){
      x = coords.get(i);
      b[0][i] = a.interp(x.x,x.y);
      x = coords.get(n-i);
      b[1][i] = a.interp(x.x,x.y);
    }
    x = coords.get(m);
    b[0][m] = a.interp(x.x,x.y); b[1][m] = b[0][m];
    return b;
  }

   public float offset( float x ){
    return 5*(0.2969f*sqrt(x)-0.1260f*x-0.3516f*pow(x,2)+0.2843f*pow(x,3)-0.1015f*pow(x,4));
  }
}
// Class to hold the ortho-normal project terms of a line segment

class OrthoNormal{
  float l,nx,ny,tx,ty,off,t1,t2;
  PVector cen;

  OrthoNormal(){ this(new PVector(0,0), new PVector(0,1));}
  OrthoNormal(PVector x1, PVector x2 ){ // set the ortho-normal values based on two points
    l = PVector.sub(x1,x2).mag();
    tx = (x2.x-x1.x)/l;    // x tangent
    ty = (x2.y-x1.y)/l;    // y tangent
    t1 = x1.x*tx+x1.y*ty;  // tangent location of point 1
    t2 = x2.x*tx+x2.y*ty;  // tangent location of point 2
    nx = -ty; ny = tx;     // normal vector
    off = x1.x*nx+x1.y*ny; // normal offset
    cen = PVector.add(x1,x2); // centriod
    cen.div(2.f);
  }

   public float distance( float x, float y, Boolean projected){ // distance function
    float d = x*nx+y*ny-off; // normal distance to line 
    if(projected) return d;  // |distance|_n (signed, fastest)
    float d1 = x*tx+y*ty-t1; // tangent dis to start
    float d2 = x*tx+y*ty-t2; // tangent dis to end
//    return sqrt(sq(d)+sq(max(0,-d1))+sq(max(0,d2))); // |distance|_2
    return abs(d)+max(0,-d1)+max(0,d2);              // |distance|_1 (faster)
  }
   public float distance( float x, float y){ return distance(x,y,true); } // default to signed dist

   public float tanCoord( float x, float y ){ // tangent coordinate
    return min(max((x*tx+y*ty-t1)/l,0),1);
  }

   public void translate(float dx, float dy){
    t1 += dx*tx+dy*ty;
    t2 += dx*tx+dy*ty;
    off += dx*nx+dy*ny;
    cen.add(dx,dy,0);
  }

   public void print(){
    println("t=["+tx+","+ty+"]");
    println("n=["+nx+","+ny+"]");
    println("offsets=["+t1+","+t2+","+off+"]");
  }
}
/**********************************
PoissonMatrix class

Holds values and operators for a Poisson matrix

   A*x = div{lower*grad{x}} = b      (1)

where lower is a VectorField which are the 
lower diagonal components of the matrix A.
From Eq.1 the matrix is symmetric and the
diagonals are given by 

  sum{a_{i,j},i} = 0 forall j       (2)

example code:

void setup(){
  colorMode(RGB,1.0);
  size(500,500);
  VectorField c = new VectorField(40,40,0,0);
  c.x.eq(1.); c.y.eq(1.); c.setBC();
  PoissonMatrix A = new PoissonMatrix(c);
  Field x = new Field(40,40,0,1);
  for(int i=0; i<40; i++ ){
  for(int j=0; j<40; j++ ){
    x.a[i][j] = i*i-j*j;
  }
  }
  Field Ax = A.times(x);
  Ax.display(-2,2);
}
***********************************/
public class PoissonMatrix {
  int n, m;
  VectorField lower;
  Field diagonal,inv;

  PoissonMatrix( VectorField lower ){
    this.n = lower.n;
    this.m = lower.m;
    this.lower = new VectorField(lower);
    diagonal = new Field(n,m);
    inv = new Field(n,m,0,1);
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      float sumd = lower.x.a[i][j]+lower.x.a[i+1][j]
                  +lower.y.a[i][j]+lower.y.a[i][j+1];
      diagonal.a[i][j] = -sumd;
      if(sumd>1e-5f) inv.a[i][j] = -1.f/sumd;
    }}
  }

   public Field times( Field x ){
    Field ab = new Field(n,m);
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      ab.a[i][j] = x.a[i][j]*diagonal.a[i][j]
                  +x.a[i-1][j]*lower.x.a[i][j]
                  +x.a[i+1][j]*lower.x.a[i+1][j]
                  +x.a[i][j-1]*lower.y.a[i][j]
                  +x.a[i][j+1]*lower.y.a[i][j+1];
    }} 
    return ab;
  }

   public Field residual( Field b, Field x ){
    return b.minus(this.times(x));
  }
}
/**********************************
 ReadData class
 
 Reads timestamped data from a file to use in Lilypad
 
 ----example code fragment:
 reader = new ReadData("FileToRead.txt");
 float dat = reader.interpolate(t, column);
 ----see use in InlineFoilTest.pde
 
 ----the file should look like this, with Tabs between the data:
 #rows #cols dt <AnyOtherInfoYouWant (Optional)>
 data00 data01 data02....
 data10 data11 data12....
 ...
 
 each row is the data at a timestep - 0zth row is t=0, 1st is t=dt, etc
 
 ----you can create this file type in matlab with these commands (if 'arr' is the array of data, 'dt' is your timestep, and 'filepath' is a string that points to a text file)
header = [size(arr,1) size(arr,2) dt <AnyOtherInfoYouWant>]
save(filepath,'header','-ascii', '-tabs');
save(filepath,'arr','-append','-ascii', '-tabs');
 ***********************************/

class ReadData {
  float[][] data;
  BufferedReader reader;
  String line;
  float dat=0, dt=1;
  String[] header;
  int rows, cols;
  boolean verbose = false;
  char delim = TAB;

  ReadData(String filepath) {
    reader = createReader(filepath);
    readAll();
  }

   public void readAll() {
    try {
      line = reader.readLine();
      header = split(line, delim);
      rows = PApplet.parseInt(PApplet.parseFloat(header[0]));
      cols = PApplet.parseInt(PApplet.parseFloat(header[1]));
      dt =  PApplet.parseFloat(header[2]);
      data = new float[rows][cols];
    }
    catch (Exception e) {
      println("Error - Bad Header");
      println(rows);
      e.printStackTrace();
    }
    if (verbose) {
      println("#Rows: " + rows + "  #Cols: " + cols + "  dt: " + dt);
    }
    for (int i=0; i<rows; i++) {
      try {
        line = reader.readLine();
      } 
      catch (Exception e) {
        println("Error - Ran out of Data");
        e.printStackTrace();
      }
      String[] pieces = split(line, delim);
      for (int j=0; j<cols; j++) {
        dat = PApplet.parseFloat(pieces[j]);
        if (verbose) {
          println("Row: " + i + "  Col: " + j + "  t: " + i*dt + "  Data: " + dat + "#Rows: " + rows);
        }
        data[i][j] = dat;
      }
    }
  }
   public float interpolate(float t, int column) {
    int index = floor(t/dt)%rows;
    int next = ceil(t/dt)%rows;
    if (verbose) {
      println("Index: " + index + "  Next: " + next + "  t: " + t + "  Column: " + column);
    }
    if (column>=cols || column<0) {
      throw new Error("Requested data column not within data");
    }

    if (index==next) {
      return data[index][column];
    }

    float slope = (data[next][column]-data[index][column])/dt;
    return data[index][column]+(t%(dt*rows)-index*dt)*slope;
  }
} 
// Single foil class

class RotatingFoil {
  final int n, m;
  float dt = 0, t = 0, dAoA, uAoA,dA,uA, omega, phi,chord = 1.0f, period, dfrac=0.5f,St;
  float AoF, v2, pitch=0, Heave = 0,p=0 , D = 0.15f;
  float F;
  float b=50; //note b/resolution is true time constant...
  int resolution;

  boolean upstroke = false;

  Body foil; 
  BDIM flow; 
  FloodPlot flood, flood2; 
  Window window;
  ReadData reader;
  PVector force;

  RotatingFoil( int resolution, int xLengths, int yLengths, float dtReal,float name1,float name2,float name3, int Re, boolean QUICK) {
    this.resolution = resolution;
    n = xLengths*resolution;
    m = yLengths*resolution;
    window = new Window(n, m);
    float M = (name1)/100;
    float P = 10*(name2);
    P = P/100;
    float T = name3;
    T = T/100;
    if(P == 0){
       foil = new NACA(n/4*3, m/2, resolution*chord, T, window); 
    }
    else{
      foil = new generateNaca(n/4*3,m/2,name1,name2,name3, resolution*chord ,window); 
    }

   // NACA0015
    foil.rotate(-foil.phi+PI);
    foil.rotate(0);
    
    this.dt = dtReal*this.resolution;
    flow = new BDIM(n, m, dt, foil, (float)resolution/Re, QUICK, -1); // flow is from right to left, which accords to the right-hand coord

    //flow.write("pitch\\saved\\init.bdim");
    flood = new FloodPlot(window);
    flood.range = new Scale(-0.5f, 0.5f);
    flood.setLegend("vorticity");
    flood.setColorMode(1); 
    foil.setColor(0xFFCCCCCC);
  }
  
   public void setFlapParams(float St, float dAoA, float uAoA, float dA, float uA, float phi ) {
    this.St = St;
    this.dAoA = dAoA; 
    this.uAoA = uAoA; 
    this.dA = dA; 
    this.uA = uA;
    this.phi = phi;
    //this.omega = TWO_PI/resolution * stru/(2*1.0*chord);
    //this.omega = TWO_PI * St/(1.0*chord);  orignal flapping freq 
    this.omega = TWO_PI * St/(1.0f*chord);
    this.period = TWO_PI/omega;
    //foil.translate(0,0);
  }

   public void computeState(float t) {
    AoF = atan2(0.f, 1.f);
    v2 = 1;
    PVector pforce = foil.pressForce(flow.p);
    F = pforce.y*cos(AoF)+pforce.x*sin(AoF);
  }

   public float computePitch(float t) {
    float pitchAmp = dAoA;
    if (pitch<=0) {
      pitchAmp = uAoA;
    }
    return pitchAmp*sin(omega*t+phi)+AoF; // position control
    //return pitchAmp*omega*cos(omega*t); // vel control
  }
     public float computeHeave(float t) {
    float HeaveAmp = dA;
    if (Heave<=0) {
      HeaveAmp = uA;
    }
    return HeaveAmp*sin(omega*t)+m/2.f; // position control
    //return HeaveAmp*omega*cos(omega*t); // vel control
  }
   public void update2(){
    //flow.dt = this.dt;
    if (flow.QUICK) {
      dt = flow.checkCFL();
      flow.dt = dt;
    }
    computeState(t);
    pitch = computePitch(t);
    //foil.rotate(0*flow.dt); // vel control
    foil.rotate(-foil.phi-pitch+PI); // position control
    Heave = computeHeave(t);
    //foil.translate(0.,3*flow.dt); // vel control
    foil.translate(0.f,Heave - foil.xc.y); // position control
    
    flow.update(foil);flow.update2();
    t += dt/resolution;  //nonedimension
    force = foil.pressForce(flow.p);
    
    print("t="+nfs(t,2,3)+";  ");
    print("drag="+nfs(force.x*2/this.resolution, 2, 2)+";  ");
    print("lift="+nfs(force.y*2/this.resolution, 2, 2)+";  ");
    print("St="+nfs(St, 2, 2)+";  ");
    //print("dt="+nfs(0.3*flow.dt,2,3)+";  ");
    println("AoA: "+(pitch-AoF)*180/PI);
    
  }
  
   public void update() {
    if (flow.QUICK) {
      dt = flow.checkCFL();
      flow.dt = dt;
    }

    computeState(t);
    pitch = computePitch(t);
    foil.rotate(-foil.phi-pitch+PI);
    Heave = computeHeave(t);
    foil.translate(0.f,Heave - foil.xc.y);
    println("AoA: "+(pitch-AoF)*180/PI);

    flow.update(foil);flow.update2();
    t += dt;
    
    print("t="+nfs(t/resolution,2,2)+";  ");
  }
  
   public void display() {
    flood.display(flow.u.curl());
    foil.display();
    //foil.displayVector(foil.pressForce(flow.p));
  }
}
/**********************************
 SaveData class
 
Saves data to a text file with customizable header
 
---- example code fragment:
 dat = new SaveData("pressure.txt",test.foil.fcoords,resolution,xLengths,yLengths,zoom);
 dat.addData(test.t, test.flow.p);
 dat.finish();
----see use in InlineFoilTest.pde, AudreyTest.pde, etc
***********************************/
 
class SaveData{
  ArrayList<PVector> coords;
  PrintWriter output;
  int n;
  
  SaveData(String name, ArrayList<PVector> coords, int resolution, int xLengths, int yLengths, int zoom){
    output = createWriter(name);
    this.coords = coords;
    n = coords.size();
    output.println("%% Pressure distribution along the foil using processing viscous simulation");
    output.print("% xcoord = [");
    for(int i=0; i<n; i++){
      output.print(coords.get(i).x +" ");
    }
    output.println("];");
    
    output.print("% ycoord = [");
    for(int i=0; i<n; i++){
      output.print(coords.get(i).y +" ");
    }
    output.println("];");
  
    output.print("% resolution = "+ resolution);
    output.print("; xLengths = "+ xLengths);
    output.print("; yLengths = "+ yLengths);
    output.print("; zoom = "+ zoom);
    output.println(";");  
}
     
   public void saveParam(String name, float value){
    output.println("% " + name + " = " + value + ";");
  }
   public void saveString(String s){
    output.println(s);
  }
  
   public void addData(float t, Field a){
    output.print(t + " ");
    for(int i=0; i<n; i++){
      output.print(a.linear( coords.get(i).x, coords.get(i).y ) +" ");
    }
    output.println(";");
  }
  
   public void addData(float t, PVector p, Body b, Field a){
    output.print(t + " ");
    output.print(p.x + " " + p.y + " ");
    output.print(b.xc.x + " " + b.xc.y + " ");
    for(int i=0; i<n; i++){
      output.print(b.coords.get(i).x + " " + b.coords.get(i).y + " ");
      output.print(a.linear( b.coords.get(i).x, b.coords.get(i).y ) +" ");
    }
    output.println(";");
  }
  
   public void addDataSimple(float t, PVector p){  //simplified to only output time and vector x and y values 
    output.print(t + " ");
    output.print(p.x + " " + p.y + " ");
    output.println(";");
  }

   public void addText(String s){   //allows to insert text anywhere in txt
    output.println(s);
  }

   public void finish(){
    output.flush(); // Writes the remaining data to the file
    output.close(); // Finishes the file
  }
} 
  
 
/**********************************
 SaveScalar class
 
 Saves scalar data to a text file with customizable header
 
 example code:
 // dat = new SaveData("pressure.txt",test.body.);
 dat.addData(test.t, test.flow.p);
 dat.finish();
 ***********************************/

class SaveScalar{
  PVector force;
  PrintWriter output;
  int n;
  float  resolution, xi1, xi2, theta, D;
  float centX, centY;
  int numTheta;
  
  SaveScalar(String name){
    output = createWriter(name);
    output.println("%% Force coefficients using processing viscous simulation");
    output.println();
    output.println("%% Fellowing: t, force.x, force.y");
    output.println();
  }
  
  SaveScalar(String name, float res, float xLen, float yLen, int num){
    output = createWriter(name);
    output.println("%% Force and pressure coefficients using processing viscous simulation");
    output.println();
    output.println("%% Fellowing: t, force.x, force.y");
    output.println();
    this.resolution = res;
    this.D = res;
    float n = xLen*res;
    float m = yLen*res;
    this.numTheta = num;
    this.centX = n/4;
    this.centY = m/2;
  }
     
   public void addData(float t,PVector force){
    output.println(t + " " + force.x + " " +force.y);
    output.println("");
  }
  
   public void addData02(float t,PVector force, Field pres){
    output.print(t + " " + force.x + " " +force.y + " ");
    for(int i=0;i<numTheta; i++){
      float xPre = cos((float)i/numTheta*PI*2)*D/2 + centX;
      float yPre = sin((float)i/numTheta*PI*2)*D/2 + centY;
      
      float pdl = pres.linear( xPre, yPre );
      output.print(pdl + " ");
    }
    //output.println("");
    output.println("");
  }
  
   public void addData03(float t,PVector force, Field pres){
    output.print(t + " " + force.x + " " +force.y + " ");
    for(int i=0;i<numTheta; i++){
      float xPre = cos((float)i/numTheta*PI*2)*D/2 + centX;
      float yPre = sin((float)i/numTheta*PI*2)*D/2 + centY;
      
      float pdl = pres.linear( xPre, yPre );
      output.print(pdl + " ");
    }
    //output.println("");
    output.println("");
  }
  
  
   public void finish(){
    output.flush(); // Writes the remaining data to the file
    output.close(); // Finishes the file
  }
} 
  
/**********************************
 SaveVectorField class
 
Saves the velocity and pressure field to a text file with customizable header
These files can be quite large!

example code:

SaveVectorField data;
AudreyTest test;

void setup(){
  int resolution = 128, xLengths=6, yLengths=3, zoom = 1;
  float xStart = -4, yDist =0.2;
  test = new AudreyTest(resolution, xLengths, yLengths, xStart , yDist, zoom);
  test.update();

  data = new SaveVectorField("saved/data.txt",test.body.a.coords,test.Re,resolution, test.n,test.m);
  data.addField(test.flow.u,test.flow.p);
  data.finish();
}
***********************************/

class SaveVectorField {
  PrintWriter output;
  int m, n;

  SaveVectorField(String name, ArrayList<PVector> coords, float Re, int resolution, int n, int m) {
    this.m = m;
    this.n = n;
    output = createWriter(name);
    output.println("%% Steady field generated by a NACA foil. u, followed by v, followed by p");
    output.print("% xcoord = [");
    for (int i=0; i<coords.size(); i++) {
      output.print(coords.get(i).x +" ");
    }
    output.println("];");

    output.print("% ycoord = [");
    for (int i=0; i<coords.size(); i++) {
      output.print(coords.get(i).y +" ");
    }
    output.println("];");

    output.print("% resolution = "+ resolution);
    output.print("; n = "+ n);
    output.print("; m = "+ m);
    output.print("; Re = "+ Re);
    output.println(";");
  }


   public void addField(VectorField u, Field p) {
    for (int j=1; j<m-1; j++) {
      for (int i=1; i<n-1; i++) {
        output.print(u.x.a[i][j] +" ");
      }
      output.println(";");
    }
    for (int j=1; j<m-1; j++) {
      for (int i=1; i<n-1; i++) {
        output.print(u.y.a[i][j] +" ");
      }
      output.println(";");
    }
    for (int j=1; j<m-1; j++) {
      for (int i=1; i<n-1; i++) {
        output.print(p.a[i][j] +" ");
      }
      output.println(";");
    }
  }

   public void finish() {
    output.flush(); // Writes the remaining data to the file
    output.close(); // Closes the file
  }
} 
/******************************************
 StreamPlot
 
  Draws the streamlines on top of a regular plot, using the stream function
 example code:
 
BDIM flow;
CircleBody body;
StreamPlot flood;

void setup(){
  int n=(int)pow(2,6);   // number of grid points
  int nlines = 15;       // number of streamlines
  size(400,400);         // display window size
  Window view = new Window(n,n);

  body = new CircleBody(n/3,n/2,n/8,view); // define geom
  flow = new BDIM(n,n,1.5,body);           // solve for flow using BDIM

  flood = new StreamPlot(view,flow,nlines);
  flood.range = new Scale(-.75,.75);
  flood.setLegend("vorticity");
  flood.setLineColor(0);
  flood.setLineThickness(0.1);
}
void draw(){
  body.update();
  flow.update(body);
  flow.update2();
  flood.display(flow.u.curl());
  body.display();
}
void mousePressed(){body.mousePressed();}
void mouseReleased(){body.mouseReleased();}
 ********************************************/

class StreamPlot extends FloodPlot {
  BDIM flow;
  PImage streamImage;
  int nlines;
  float thickness = 0.1f; //In fraction of spacing between streamlines
  int streamcolor = 0;

  StreamPlot(Window window, BDIM flow, int nlines) {
    super( window );
    this.flow = flow;
    this.nlines = nlines;
    streamImage = new PImage(window.dx, window.dy, ARGB);
  }
   public void setLineColor(int c) {
    this.streamcolor = c;
  }
   public void setLineThickness(float thick) {
    this.thickness = thick;
  }
   public void display ( Field a ) {
    float minv = 1e6f, maxv = -1e6f;
    super.display(a);
    Field psi = flow.u.streamFunc();

    colorMode(HSB, 360, 1.0f, 1.0f, 1.0f);
    streamImage.loadPixels();
    float psimod = (float)flow.m/nlines;
    for ( int i=0 ; i<window.dx ; i++ ) {
      float x = window.ix(i+window.x0);
      for ( int j=0 ; j<window.dy ; j++ ) {
        float y = window.iy(j+window.y0);
        float streamon = ((psi.interp(x, y)) % psimod)/psimod - 0.5f;
        if (abs(streamon)<0.5f*thickness)
          streamImage.pixels[i+j*window.dx] = color(hue(streamcolor),saturation(streamcolor),brightness(streamcolor),1-abs(streamon)/(0.5f*thickness));
        else
          streamImage.pixels[i+j*window.dx] = color(0, 0);
        float f = a.interp(x, y);
        minv = min(minv, f);
        maxv = max(maxv, f);
      }
    }
    streamImage.updatePixels();
    image(streamImage, window.x0, window.y0);
    if (legendOn)
      legend.display(minv, maxv);
  }
}
/**********************************
VectorField class

Holds the values and operators for a
vector field

Example code:
void setup(){
  size(400,400);
  noStroke();
  int N = 130;
  VectorField u = new VectorField(N,N,1,-0.5);
  u.x.eq(0.,40,50,40,75);
  VectorField c = new VectorField(N,N,0,0);
  c.x.eq(1); c.y.eq(1); c.setBC();
  Field p = new Field(N,N);
//  u.project(c,p);  // uncomment to see the effect of projection on the divergence.
  u.divergence().display(-.1,.1);
}
***********************************/

class VectorField{
  Field x,y;
  int n, m;
  float CF=1.f/6.f, S=10.f;  // QUICK parameters

  VectorField( int n, int m, float xval, float yval ){
    this.n = n;
    this.m = m;
    x = new Field( n, m, 1, xval );
    y = new Field( n, m, 2, yval );
  }
  VectorField( Field x, Field y ){
    n = x.n;
    m = x.m;
    this.x = new Field(x);
    this.y = new Field(y);
  }
  VectorField( VectorField b ){this( b.x, b.y );}
  
   public void setBC(){
    x.setBC(); 
    y.setBC(); 
  }

   public VectorField normalGrad(VectorField wnx, VectorField wny){
    VectorField g = new VectorField(n,m,0,0);
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      g.x.a[i][j] = 0.5f*(wnx.x.a[i][j]*(x.a[i+1][j]-x.a[i-1][j])+wny.x.a[i][j]*(x.a[i][j+1]-x.a[i][j-1]));
      g.y.a[i][j] = 0.5f*(wnx.y.a[i][j]*(y.a[i+1][j]-y.a[i-1][j])+wny.y.a[i][j]*(y.a[i][j+1]-y.a[i][j-1]));
    }}
    return g; 
  }

   public Field divergence (){
    // returns div{this} for unit cells
    Field d = new Field( n, m );
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      d.a[i][j] = x.a[i+1][j]-x.a[i][j]+
                  y.a[i][j+1]-y.a[i][j];
    }}
    return d;
  }

   public Field ke (){
    // returns 0.5*{this-bval}^2 for unit cells
    Field d = new Field( n, m );
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      d.a[i][j] = (sq(x.a[i+1][j]+x.a[i][j]-2.f*x.bval)+
                   sq(y.a[i][j+1]+y.a[i][j]-2.f*y.bval))*0.125f;
    }}
    return d;
  }

   public Field curl (){
    // returns curl{this} located at cell corner (btype=3)
    Field d = new Field( n, m, 3, 0 );
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
      d.a[i][j] = x.a[i][j-1]-x.a[i][j]+
                  y.a[i][j]-y.a[i-1][j];
    }}
    return d;
  }

   public Field Qcrit (){
    Field q = new Field( n, m );
    for ( int i=1 ; i<n-1 ; i++ ) {
    for ( int j=1 ; j<m-1 ; j++ ) {
    float dudx = 0.5f*(x.a[i+1][j]-x.a[i-1][j]);
    float dudy = 0.5f*(x.a[i][j+1]-x.a[i][j-1]);
    float dvdx = 0.5f*(y.a[i+1][j]-y.a[i-1][j]);
    float dvdy = 0.5f*(y.a[i][j+1]-y.a[i][j-1]);
    q.a[i][j] = dudx*dvdy-dvdx*dudy;
    }}
    return q;
  }
   public Field streamFunc() {
    //Integrates the flow field to get a stream function
    Field psi = new Field( n, m );
    float[][] s1 = new float[n][m];
    float[][] s2 = new float[n][m];

    //Integrate from top left corner
    for (int i=0 ; i<n ; i++ )
      s1[i][0] = 0;
    for (int i=0 ; i<n ; i++ )
      for (int j=1 ; j<m ; j++ )
        s1[i][j] = s1[i][j-1]+0.5f*(x.a[i][j-1]+x.a[i][j]);

    //Integrate from lower right corner
    s2[n-1][m-1]=0;
    for (int i=n-2; i>=0; i--)
      s2[i][m-1] = 0;
    for (int i=0 ; i<n ; i++ )
      for (int j=m-2 ; j>=0; j-- )
        s2[i][j] = s2[i][j+1]-0.5f*(x.a[i][j+1]+x.a[i][j]);

    //Average both solutions
    float basepsi = s2[0][0];
    for (int i=0 ; i<n ; i++ )
      for (int j=0 ; j<m ; j++ )
        psi.a[i][j] = 0.5f*(s1[i][j] + s2[i][j]-basepsi);    
    return psi;
  }

   public Field project ( VectorField coeffs, Field p, Field s ){
    /* projects u,v onto a divergence-free field using
         div{coeffs*grad{p}} = div{u}  (1)
         u -= coeffs*grad{p}           (2)
       and returns the field p. all FDs are on unit cells */
    p = MGsolver( 20, new PoissonMatrix(coeffs), p , s );
    p.plusEq(-1*p.sum()/(float)((n-2)*(m-2)));
    VectorField dp = p.gradient();
    x.plusEq(coeffs.x.times(dp.x.times(-1)));
    y.plusEq(coeffs.y.times(dp.y.times(-1)));
    setBC();
    return p;
  }
   public Field project ( VectorField coeffs, Field p ){ return project(  coeffs, p, this.divergence() ); }

   public void display( float unit, int skip){
    stroke(0xFF993333);
    float DX = width/(float)n;
    float DY = height/(float)m;
    for ( int i=0 ; i<n ; i+=skip ) {
    for ( int j=0 ; j<m ; j+=skip ) {
      float px = i*DX;
      float py = j*DY;
      arrow(px,py,px+DX*unit*x.a[i][j],py+DY*unit*y.a[i][j]);
    }}
    noStroke();
  }  
  private void arrow(float x1, float y1, float x2, float y2) {
    float a = atan2(x1-x2, y2-y1);
    float b = 0.1f*mag(x1-x2, y2-y1);
//    if(b<.1) return;
    line(x1, y1, x2, y2);
    pushMatrix();
      translate(x2, y2);
      rotate(a);
      line(0, 0, -b, -b);
      line(0, 0,  b, -b);
    popMatrix();
  } 
  
    public void AdvDif(VectorField u0, float dt, float nu) {
     VectorField v = new VectorField(this);
     for ( int j=1; j<m-1; j++) {
      for ( int i=1; i<n-1; i++) {
        v.x.a[i][j] = (advection(x, i, j) + nu*diffusion(x, i, j))*dt+u0.x.a[i][j];
        v.y.a[i][j] = (advection(y, i, j) + nu*diffusion(y, i, j))*dt+u0.y.a[i][j];
      }
    }
    this.eq(v);   
  }

   public float advection (Field b, int i, int j) {  
    float uo, ue, vs, vn;
    if (b.btype == 1) {
      uo = 0.5f*(x.a[i-1][j]+x.a[i][j]);
      ue = 0.5f*(x.a[i+1][j]+x.a[i][j]);
      vs = 0.5f*(y.a[i][j]+y.a[i-1][j]);
      vn = 0.5f*(y.a[i][j+1]+y.a[i-1][j+1]);
    }
    else {
      uo = 0.5f*(x.a[i][j-1]+x.a[i][j]);
      ue = 0.5f*(x.a[i+1][j-1]+x.a[i+1][j]);
      vs = 0.5f*(y.a[i][j-1]+y.a[i][j]);
      vn = 0.5f*(y.a[i][j]+y.a[i][j+1]);
    }
    return ((uo*bho(b, i, j, -1, 0, uo) - ue*bho(b, i, j, 1, 0, ue)) + (vs*bho(b, i, j, 0, -1, vs) - vn*bho(b, i, j, 0, 1, vn)));
  }

   public float diffusion (Field b, int i, int j) {
    return b.a[i+1][j] + b.a[i][j+1] - 4*b.a[i][j] + b.a[i-1][j] + b.a[i][j-1];
  }

   public float bho(Field b, int i, int j, int d1, int d2, float uf) {
    float bf =  0.5f*(b.a[i+d1][j+d2]+b.a[i][j]); 
    if (d1*uf<0){
     i += d1; 
     d1 = -d1;
    }
    if (d2*uf<0){
     j += d2;
     d2 = -d2;
    } 
    if ( i>n-2 || i<2 || j>m-2 || j<2 ) return bf;
    float bc = b.a[i][j];
    float bd = b.a[i+d1][j+d2];
    float bu = b.a[i-d1][j-d2];
    bf -= CF*(bd-2*bc+bu);
    float b1 = bu+S*(bc-bu);
    return med(bf, bc, med(bc, bd, b1));
  }

   public float med(float a, float b, float c) {
    return(max(min(a, b), min(max(a, b), c)));
  }

   public float CFL(float nu) {
    float b = abs(x.a[0][0])+abs(y.a[0][0]);
    float c;
    for ( int i=1; i<n-1; i++) {
      for ( int j=1; j<m-1; j++) { 
        c = abs(x.a[i][j])+abs(y.a[i][j]);
        if (c>b) b=c;
      }
    }
    return 1.f/(b+3.f*nu);
  }
  
   public VectorField times( VectorField b){
    VectorField g = new VectorField(this);
    g.timesEq(b);
    return g;
  }
  
   public VectorField times( float b){
    VectorField g = new VectorField(this);
    g.timesEq(b);
    return g;
  }
  
   public VectorField plus( VectorField b){
    VectorField g = new VectorField(this);
    g.plusEq(b);
    return g;
  }
  
   public VectorField minus( VectorField b){
    VectorField g = new VectorField(this);
    g.minusEq(b);
    return g;
  }
  
   public VectorField plus( float b){
    VectorField g = new VectorField(this);
    g.plusEq(b);
    return g;
  }  

   public VectorField inv(){ 
    VectorField g = new VectorField(this);
    g.invEq();
    return g;
  }

   public VectorField laplacian(){
    return new VectorField(x.laplacian(),y.laplacian());
  }
  
   public void eq( VectorField b ){ x.eq(b.x); y.eq(b.y);}
   public void eq( float b ){ x.eq(b); y.eq(b);}
   public void timesEq( VectorField b ){ x.timesEq(b.x); y.timesEq(b.y);}
   public void timesEq( float b ){ x.timesEq(b); y.timesEq(b);}
   public void plusEq( VectorField b ){ x.plusEq(b.x); y.plusEq(b.y);}
   public void plusEq( float b ){ x.plusEq(b); y.plusEq(b);}  
   public void plusEq( PVector b ){ x.plusEq(b.x); y.plusEq(b.y);}  
   public void minusEq( VectorField b ){ x.minusEq(b.x); y.minusEq(b.y);}  
   public void advect( float dt, VectorField b ){ x.advect(dt,b); y.advect(dt,b);}
   public void advect( float dt, VectorField b, VectorField b0 ){ x.advect(dt,b,b0); y.advect(dt,b,b0);}
   public void invEq(){ x.invEq(); y.invEq();}  
}
/*************************
 Vortex class
 
 This is an example class for initializing the flow with one or more Rankine 
 vortices.  In the example code, a vortex pair is initialized in a quiescent 
 flow and then moves with its self-induced velocity.
 
 Example code:
//INPUT PARAMETERS_______________________________________________________________________
int resolution = 8;            // number of grid points spanning vortex diameter
int xLengths = 16;             // (streamwise length of computational domain)/(resolution)
int yLengths = 8;              // (transverse length of computational domain)/(resolution)
int area = 300000;             // window view area
int Re = 1000;                 // Reynolds number
float q = 1;                   // vortex circulation
float sep = 1;                 // (separation between opposite sign vortices)/(core diameter)
//_______________________________________________________________________________________

Vortex test;

void settings(){
  float s = sqrt(area*xLengths/yLengths);
  size((int)s, (int)s*yLengths/xLengths);
}
void setup() {
  test = new Vortex(resolution, Re, xLengths, yLengths, q, sep);
}

void draw() {
  test.update(); 
  test.display();
}

void keyPressed(){exit();}
***********************/


class Vortex {
  BDIM flow;
  boolean QUICK = true, order2 = true;
  int n, m, resolution;
  float dCore, q, sep, xc, yc, dt=1;
  CircleBody body;
  FloodPlot flood;
  VectorField u0;

  Vortex(int resolution, int Re, int xLengths, int yLengths, float q, float sep) {
    this.resolution = resolution;
    n=xLengths*resolution+2;
    m=yLengths*resolution+2;
    Window view = new Window(0, 0, n, m);
    this.dCore = resolution;
    this.q = q;
    this.sep = sep;
    this.u0 = new VectorField(n, m, 0, 0);
    xc = 0.2f*n;
    yc = 0.5f*m;
  
    //set up an initial velocity field of a Rankine vortex pair
    for ( int i=1 ; i<n-1 ; i++ ) {
      for ( int j=1 ; j<m-1 ; j++ ) {
        for ( int btype=1 ; btype<3 ; btype++ ) {
          float x = i;
          float y = j;
          if (btype==1) {
            x -= 0.5f;
          }
          if (btype==2) {
            y -= 0.5f;
          }
          //first vortex
          if (btype==1) {
            u0.x.a[i][j] += vortexX(x, y, xc, (yc - sep*dCore/2), -1);
          }
          if (btype==2) {
            u0.y.a[i][j] += vortexY(x, y, xc, (yc - sep*dCore/2), -1);
          }
          //second vortex
          if (btype==1) {
            u0.x.a[i][j] += vortexX(x, y, xc, (yc + sep*dCore/2), 1);
          }
          if (btype==2) {
            u0.y.a[i][j] += vortexY(x, y, xc, (yc + sep*dCore/2), 1);
          }
        }
      }
    }
    
    flow = new BDIM(n-2, m-2, 0, u0, (float)resolution/Re, QUICK);

    flood = new FloodPlot(view); 
    flood.range = new Scale(-.5f, .5f);
    flood.setLegend("vorticity");
  }

  // the integer pos specifies if the circulation is positive or negative
   public float vortexX( float x, float y, float xc, float yc, int pos) {
    float c;
    if ((sq(x-xc) + sq(y-yc)) <= sq(dCore/2)) {
      c = -pos*q*(y-yc);
    } 
    else {
      c = -pos*q*sq(dCore/2)/( sq(x-xc) + sq(y-yc) )*(y-yc);
    }
    return c;
  }  

   public float vortexY( float x, float y, float xc, float yc, int pos) {
    float c;
    if ((sq(x-xc) + sq(y-yc)) <= sq(dCore/2)) {
      c = pos*q*(x-xc);
    } 
    else {
      c = pos*q*sq(dCore/2)/( sq(x-xc) + sq(y-yc))*(x-xc);
    }  
    return c;
  }

   public void update() {
    if (QUICK) {
      dt = flow.checkCFL();
      flow.dt = dt;
    }
    
    flow.update();
    if (order2) {
      flow.update2();
    }
  }

   public void display() {
    flood.display(flow.u.curl());
  }
}
/********************************************
  Class to hold display window parameters
    and functions to convert from
    pixels to other units

Example code:
void setup(){
  size(300,450);
  Window mine = new Window(1,1,10,15,40,80,200,300);
  rect(40,80,200,300);
  stroke(255,0,0);fill(0,255,255);
  rect(mine.px(0.5),mine.py(0.5),mine.x.r,mine.y.r);
  rect(mine.px(9.5),mine.py(14.5),mine.x.r,mine.y.r);
  line(mine.px(1),mine.py(1),mine.px(10),mine.py(15));
  rect(mine.px(mine.ix(0)),mine.py(mine.iy(449)),50,-50);
  rect(mine.px(mine.ix(299)),mine.py(mine.iy(0)),-50,50);
}
*********************************************/

class Window{
  Scale x,y;
  int x0,y0,dx,dy;
  
  Window(){ this( 0.f, 0.f, 1.f, 1.f, 0, 0, width, height );}
  Window( int n, int m){ this( 1, 1, n-2, m-2, 0, 0, width, height );}
  Window( int n0, int m0, int dn, int dm){this( n0, m0, dn, dm, 0, 0, width, height );}
  Window( int n0, int m0, int dn, int dm, int x0, int y0, int dx, int dy){
    this(n0-0.5f,m0-0.5f,dn,dm,x0,y0,dx,dy);}
  Window( int n0, float m0, int dn, float dm, int x0, int y0, int dx, int dy){
    this(n0-0.5f,m0,dn,dm,x0,y0,dx,dy);}
  Window( float n0, float m0, float dn, float dm, int x0, int y0, int dx, int dy){
    x = new Scale(n0,n0+dn,x0,x0+dx);
    y = new Scale(m0,m0+dm,y0,y0+dy);
    this.x0 = x0;
    this.y0 = y0;
    this.dx = dx;
    this.dy = dy;
  }
   public float ix(int i){ return x.in((float)i);}
   public float iy(int i){ return y.in((float)i);}
   public float idx(int i){ return i/x.r;}
   public float idy(int i){ return i/y.r;}
   public int px(float i){ return (int)(x.out(i));}
   public int py(float i){ return (int)(y.out(i));}
   public int pdx(float i){ return (int)(x.r*i);}
   public int pdy(float i){ return (int)(y.r*i);}
   public boolean inside( int x, int y ){
    return( x>=x0 && x<=x0+dx && y>=y0 && y<=y0+dy );
  }
}

class Scale{
  float inS,inE,outS,outE,r;

  Scale( float outS, float outE ){ this(0,1,outS,outE);}
  Scale( float inS, float inE, float outS, float outE ){
    this.inS  = inS;
    this.inE  = inE;
    this.outS = outS;
    this.outE = outE;
    r = (outE-outS)/(inE-inS);
  }
   public float outB( float in ){ return out(min(max(in,inS),inE));}
   public float out( float in ){ return (in-inS)*r+outS;} 
   public float in( float out ){ return (out-outS)/r+inS;}
}
/*这是一个新的NACA类，用新的算法生成翼型点的数据 */
class generateNaca extends Body{
    int n = 200;//机翼上下表面的点的数量
    float []x = new float[n];
    float []y = new float[n];
    float []yt = new float[n];//机翼不同位置的厚度
    float []xu = new float[n];
    float []yu = new float[n];
    float []xl = new float[n];
    float []yl = new float[n];
    float []theta = new float[n];
    float c;
    generateNaca(float xc,float yc,float name1,float name2,float name3,float c,Window window){
        super(xc,yc,window);
        float M =(name1)/100;
        float P = 10*name2;
        P = P/100;
        float T = name3;
        T = T/100;
        for(int i=0;i<n;i++){
            x[i] = i*1.0f/(n-1);
            if(x[i] <= P){
                y[i] = M/(pow(P,2))*(2*P*x[i] - pow(x[i],2));
            }
            else{
                y[i] = M / (pow(1-P,2))*((1-2*P)+2*P*x[i]-pow(x[i],2));
            }
            yt[i] = T/0.2f*(0.2969f*sqrt(x[i])-0.1260f*x[i]-0.3516f*pow(x[i],2)+0.2843f*pow(x[i],3)-0.1015f*pow(x[i],4));
            

        }
        for(int i=0;i<n;i++){
            if(i==n-1){
                theta[i] = theta[i-1];
            }
            else{
                theta[i] = atan(((y[i + 1] - y[i])/(1.0f/(n-1))));
            }
             xu[i] = x[i] - yt[i] * sin(theta[i]);
             yu[i] = y[i] + yt[i] * cos(theta[i]);
             xl[i] = x[i] + yt[i] * sin(theta[i]);
             yl[i] = y[i] - yt[i] * cos(theta[i]);
        }
        for(int i=0;i<n;i++){
            add(xc+xu[i]*c,yc+yu[i]*c);
        }
        for(int i=0;i<n-2;i++){
            add(xc+xl[n-i-1]*c,yc+yl[n-i-1]*c);
        }
        end();
        this.c = c;
    }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "MMGP_OL1" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
